{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api-reference/","title":"API Specification","text":"<p>This page contains the API field specification for Gateway API.</p> <p>Packages:</p> <ul> <li> application-networking.k8s.aws/v1alpha1 </li> </ul>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1","title":"application-networking.k8s.aws/v1alpha1","text":"<p>Resource Types:</p> <ul><li> AccessLogPolicy </li><li> IAMAuthPolicy </li><li> ServiceExport </li><li> ServiceImport </li><li> TargetGroupPolicy </li><li> VpcAssociationPolicy </li></ul>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.AccessLogPolicy","title":"AccessLogPolicy","text":"Field Description <code>apiVersion</code> string <code> application-networking.k8s.aws/v1alpha1 </code> <code>kind</code> string  <code>AccessLogPolicy</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  AccessLogPolicySpec  <code>destinationArn</code>  string  <p>The Amazon Resource Name (ARN) of the destination that will store access logs. Supported values are S3 Bucket, CloudWatch Log Group, and Firehose Delivery Stream ARNs.</p> <p>Changes to this value results in replacement of the VPC Lattice Access Log Subscription.</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the Kubernetes Gateway, HTTPRoute, or GRPCRoute resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p> <code>status</code>  AccessLogPolicyStatus  <p>Status defines the current state of AccessLogPolicy.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.IAMAuthPolicy","title":"IAMAuthPolicy","text":"Field Description <code>apiVersion</code> string <code> application-networking.k8s.aws/v1alpha1 </code> <code>kind</code> string  <code>IAMAuthPolicy</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  IAMAuthPolicySpec  <code>policy</code>  string  <p>IAM auth policy content. It is a JSON string that uses the same syntax as AWS IAM policies. Please check the VPC Lattice documentation to get the common elements in an auth policy</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the Kubernetes Gateway, HTTPRoute, or GRPCRoute resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p> <code>status</code>  IAMAuthPolicyStatus  <p>Status defines the current state of IAMAuthPolicy.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceExport","title":"ServiceExport","text":"<p>ServiceExport declares that the Service with the same name and namespace as this export should be consumable from other clusters.</p> Field Description <code>apiVersion</code> string <code> application-networking.k8s.aws/v1alpha1 </code> <code>kind</code> string  <code>ServiceExport</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta  (Optional) Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>status</code>  ServiceExportStatus  (Optional) <p>status describes the current state of an exported service. Service configuration comes from the Service that had the same name and namespace as this ServiceExport. Populated by the multi-cluster service implementation\u2019s controller.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceImport","title":"ServiceImport","text":"<p>ServiceImport describes a service imported from clusters in a ClusterSet.</p> Field Description <code>apiVersion</code> string <code> application-networking.k8s.aws/v1alpha1 </code> <code>kind</code> string  <code>ServiceImport</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta  (Optional) Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ServiceImportSpec  (Optional) <p>spec defines the behavior of a ServiceImport.</p> <code>ports</code>  []ServicePort  <code>ips</code>  []string  (Optional) <p>ip will be used as the VIP for this service when type is ClusterSetIP.</p> <code>type</code>  ServiceImportType  <p>type defines the type of this service. Must be ClusterSetIP or Headless.</p> <code>sessionAffinity</code>  Kubernetes core/v1.ServiceAffinity  (Optional) <p>Supports \u201cClientIP\u201d and \u201cNone\u201d. Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. Ignored when type is Headless More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies</p> <code>sessionAffinityConfig</code>  Kubernetes core/v1.SessionAffinityConfig  (Optional) <p>sessionAffinityConfig contains session affinity configuration.</p> <code>status</code>  ServiceImportStatus  (Optional) <p>status contains information about the exported services that form the multi-cluster service referenced by this ServiceImport.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.TargetGroupPolicy","title":"TargetGroupPolicy","text":"Field Description <code>apiVersion</code> string <code> application-networking.k8s.aws/v1alpha1 </code> <code>kind</code> string  <code>TargetGroupPolicy</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  TargetGroupPolicySpec  <code>protocol</code>  string  (Optional) <p>The protocol to use for routing traffic to the targets. Supported values are HTTP (default) and HTTPS.</p> <p>Changes to this value results in a replacement of VPC Lattice target group.</p> <code>protocolVersion</code>  string  (Optional) <p>The protocol version to use. Supported values are HTTP1 (default) and HTTP2. When a policy is behind GRPCRoute, this field value will be ignored as GRPC is only supported through HTTP/2.</p> <p>Changes to this value results in a replacement of VPC Lattice target group.</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the kubernetes Service resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p> <code>healthCheck</code>  HealthCheckConfig  (Optional) <p>The health check configuration.</p> <p>Changes to this value will update VPC Lattice resource in place.</p> <code>status</code>  TargetGroupPolicyStatus"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.VpcAssociationPolicy","title":"VpcAssociationPolicy","text":"Field Description <code>apiVersion</code> string <code> application-networking.k8s.aws/v1alpha1 </code> <code>kind</code> string  <code>VpcAssociationPolicy</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VpcAssociationPolicySpec  <code>securityGroupIds</code>  []SecurityGroupId  (Optional) <p>SecurityGroupIds defines the security groups enforced on the VpcServiceNetworkAssociation. Security groups does not take effect if AssociateWithVpc is set to false.</p> <p>For more details, please check the VPC Lattice documentation https://docs.aws.amazon.com/vpc-lattice/latest/ug/security-groups.html</p> <code>associateWithVpc</code>  bool  (Optional) <p>AssociateWithVpc indicates whether the VpcServiceNetworkAssociation should be created for the current VPC of k8s cluster.</p> <p>This value will be considered true by default.</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the kubernetes Gateway resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p> <code>status</code>  VpcAssociationPolicyStatus"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.AccessLogPolicySpec","title":"AccessLogPolicySpec","text":"<p> (Appears on:AccessLogPolicy) </p> <p>AccessLogPolicySpec defines the desired state of AccessLogPolicy.</p> Field Description <code>destinationArn</code>  string  <p>The Amazon Resource Name (ARN) of the destination that will store access logs. Supported values are S3 Bucket, CloudWatch Log Group, and Firehose Delivery Stream ARNs.</p> <p>Changes to this value results in replacement of the VPC Lattice Access Log Subscription.</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the Kubernetes Gateway, HTTPRoute, or GRPCRoute resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.AccessLogPolicyStatus","title":"AccessLogPolicyStatus","text":"<p> (Appears on:AccessLogPolicy) </p> <p>AccessLogPolicyStatus defines the observed state of AccessLogPolicy.</p> Field Description <code>conditions</code>  []Kubernetes meta/v1.Condition  (Optional) <p>Conditions describe the current conditions of the AccessLogPolicy.</p> <p>Implementations should prefer to express Policy conditions using the <code>PolicyConditionType</code> and <code>PolicyConditionReason</code> constants so that operators and tools can converge on a common vocabulary to describe AccessLogPolicy state.</p> <p>Known condition types are:</p> <ul> <li>\u201cAccepted\u201d</li> <li>\u201cReady\u201d</li> </ul>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ClusterStatus","title":"ClusterStatus","text":"<p> (Appears on:ServiceImportStatus) </p> <p>ClusterStatus contains service configuration mapped to a specific source cluster</p> Field Description <code>cluster</code>  string  <p>cluster is the name of the exporting cluster. Must be a valid RFC-1123 DNS label.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.HealthCheckConfig","title":"HealthCheckConfig","text":"<p> (Appears on:TargetGroupPolicySpec) </p> <p>HealthCheckConfig defines health check configuration for given VPC Lattice target group. For the detailed explanation and supported values, please refer to VPC Lattice documentationon health checks.</p> Field Description <code>enabled</code>  bool  (Optional) <p>Indicates whether health checking is enabled.</p> <code>intervalSeconds</code>  int64  (Optional) <p>The approximate amount of time, in seconds, between health checks of an individual target.</p> <code>timeoutSeconds</code>  int64  (Optional) <p>The amount of time, in seconds, to wait before reporting a target as unhealthy.</p> <code>healthyThresholdCount</code>  int64  (Optional) <p>The number of consecutive successful health checks required before considering an unhealthy target healthy.</p> <code>unhealthyThresholdCount</code>  int64  (Optional) <p>The number of consecutive failed health checks required before considering a target unhealthy.</p> <code>statusMatch</code>  string  (Optional) <p>A regular expression to match HTTP status codes when checking for successful response from a target.</p> <code>path</code>  string  (Optional) <p>The destination for health checks on the targets.</p> <code>port</code>  int64  <p>The port used when performing health checks on targets. If not specified, health check defaults to the port that a target receives traffic on.</p> <code>protocol</code>  HealthCheckProtocol  (Optional) <p>The protocol used when performing health checks on targets.</p> <code>protocolVersion</code>  HealthCheckProtocolVersion  (Optional) <p>The protocol version used when performing health checks on targets. Defaults to HTTP/1.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.HealthCheckProtocol","title":"HealthCheckProtocol (<code>string</code> alias)","text":"<p> (Appears on:HealthCheckConfig) </p> Value Description <p>\"HTTP\"</p> <p>\"HTTPS\"</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.HealthCheckProtocolVersion","title":"HealthCheckProtocolVersion (<code>string</code> alias)","text":"<p> (Appears on:HealthCheckConfig) </p> Value Description <p>\"HTTP1\"</p> <p>\"HTTP2\"</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.IAMAuthPolicySpec","title":"IAMAuthPolicySpec","text":"<p> (Appears on:IAMAuthPolicy) </p> <p>IAMAuthPolicySpec defines the desired state of IAMAuthPolicy. When the controller handles IAMAuthPolicy creation, if the targetRef k8s and VPC Lattice resource exists, the controller will change the auth_type of that VPC Lattice resource to AWS_IAM and attach this policy. When the controller handles IAMAuthPolicy deletion, if the targetRef k8s and VPC Lattice resource exists, the controller will change the auth_type of that VPC Lattice resource to NONE and detach this policy.</p> Field Description <code>policy</code>  string  <p>IAM auth policy content. It is a JSON string that uses the same syntax as AWS IAM policies. Please check the VPC Lattice documentation to get the common elements in an auth policy</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the Kubernetes Gateway, HTTPRoute, or GRPCRoute resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.IAMAuthPolicyStatus","title":"IAMAuthPolicyStatus","text":"<p> (Appears on:IAMAuthPolicy) </p> <p>IAMAuthPolicyStatus defines the observed state of IAMAuthPolicy.</p> Field Description <code>conditions</code>  []Kubernetes meta/v1.Condition  (Optional) <p>Conditions describe the current conditions of the IAMAuthPolicy.</p> <p>Implementations should prefer to express Policy conditions using the <code>PolicyConditionType</code> and <code>PolicyConditionReason</code> constants so that operators and tools can converge on a common vocabulary to describe IAMAuthPolicy state.</p> <p>Known condition types are:</p> <ul> <li>\u201cAccepted\u201d</li> <li>\u201cReady\u201d</li> </ul>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.SecurityGroupId","title":"SecurityGroupId (<code>string</code> alias)","text":"<p> (Appears on:VpcAssociationPolicySpec) </p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceExportCondition","title":"ServiceExportCondition","text":"<p> (Appears on:ServiceExportStatus) </p> <p>ServiceExportCondition contains details for the current condition of this service export.</p> <p>Once KEP-1623 is implemented, this will be replaced by metav1.Condition.</p> Field Description <code>type</code>  ServiceExportConditionType  <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is one of {\u201cTrue\u201d, \u201cFalse\u201d, \u201cUnknown\u201d}</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  (Optional) <code>reason</code>  string  (Optional) <code>message</code>  string  (Optional)"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceExportConditionType","title":"ServiceExportConditionType (<code>string</code> alias)","text":"<p> (Appears on:ServiceExportCondition) </p> <p>ServiceExportConditionType identifies a specific condition.</p> Value Description <p>\"Conflict\"</p> <p>ServiceExportConflict means that there is a conflict between two exports for the same Service. When \u201cTrue\u201d, the condition message should contain enough information to diagnose the conflict: field(s) under contention, which cluster won, and why. Users should not expect detailed per-cluster information in the conflict message.</p> <p>\"Valid\"</p> <p>ServiceExportValid means that the service referenced by this service export has been recognized as valid by a controller. This will be false if the service is found to be unexportable (ExternalName, not found).</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceExportStatus","title":"ServiceExportStatus","text":"<p> (Appears on:ServiceExport) </p> <p>ServiceExportStatus contains the current status of an export.</p> Field Description <code>conditions</code>  []ServiceExportCondition  (Optional)"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceImportSpec","title":"ServiceImportSpec","text":"<p> (Appears on:ServiceImport) </p> <p>ServiceImportSpec describes an imported service and the information necessary to consume it.</p> Field Description <code>ports</code>  []ServicePort  <code>ips</code>  []string  (Optional) <p>ip will be used as the VIP for this service when type is ClusterSetIP.</p> <code>type</code>  ServiceImportType  <p>type defines the type of this service. Must be ClusterSetIP or Headless.</p> <code>sessionAffinity</code>  Kubernetes core/v1.ServiceAffinity  (Optional) <p>Supports \u201cClientIP\u201d and \u201cNone\u201d. Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. Ignored when type is Headless More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies</p> <code>sessionAffinityConfig</code>  Kubernetes core/v1.SessionAffinityConfig  (Optional) <p>sessionAffinityConfig contains session affinity configuration.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceImportStatus","title":"ServiceImportStatus","text":"<p> (Appears on:ServiceImport) </p> <p>ServiceImportStatus describes derived state of an imported service.</p> Field Description <code>clusters</code>  []ClusterStatus  (Optional) <p>clusters is the list of exporting clusters from which this service was derived.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServiceImportType","title":"ServiceImportType (<code>string</code> alias)","text":"<p> (Appears on:ServiceImportSpec) </p> <p>ServiceImportType designates the type of a ServiceImport</p> Value Description <p>\"ClusterSetIP\"</p> <p>ClusterSetIP are only accessible via the ClusterSet IP.</p> <p>\"Headless\"</p> <p>Headless services allow backend pods to be addressed directly.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.ServicePort","title":"ServicePort","text":"<p> (Appears on:ServiceImportSpec) </p> <p>ServicePort represents the port on which the service is exposed</p> Field Description <code>name</code>  string  (Optional) <p>The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. When considering the endpoints for a Service, this must match the \u2018name\u2019 field in the EndpointPort. Optional if only one ServicePort is defined on this service.</p> <code>protocol</code>  Kubernetes core/v1.Protocol  (Optional) <p>The IP protocol for this port. Supports \u201cTCP\u201d, \u201cUDP\u201d, and \u201cSCTP\u201d. Default is TCP.</p> <code>appProtocol</code>  string  (Optional) <p>The application protocol for this port. This field follows standard Kubernetes label syntax. Un-prefixed names are reserved for IANA standard service names (as per RFC-6335 and http://www.iana.org/assignments/service-names). Non-standard protocols should use prefixed names such as mycompany.com/my-custom-protocol. Field can be enabled with ServiceAppProtocol feature gate.</p> <code>port</code>  int32  <p>The port that will be exposed by this service.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.TargetGroupPolicySpec","title":"TargetGroupPolicySpec","text":"<p> (Appears on:TargetGroupPolicy) </p> <p>TargetGroupPolicySpec defines the desired state of TargetGroupPolicy.</p> Field Description <code>protocol</code>  string  (Optional) <p>The protocol to use for routing traffic to the targets. Supported values are HTTP (default) and HTTPS.</p> <p>Changes to this value results in a replacement of VPC Lattice target group.</p> <code>protocolVersion</code>  string  (Optional) <p>The protocol version to use. Supported values are HTTP1 (default) and HTTP2. When a policy is behind GRPCRoute, this field value will be ignored as GRPC is only supported through HTTP/2.</p> <p>Changes to this value results in a replacement of VPC Lattice target group.</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the kubernetes Service resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p> <code>healthCheck</code>  HealthCheckConfig  (Optional) <p>The health check configuration.</p> <p>Changes to this value will update VPC Lattice resource in place.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.TargetGroupPolicyStatus","title":"TargetGroupPolicyStatus","text":"<p> (Appears on:TargetGroupPolicy) </p> <p>TargetGroupPolicyStatus defines the observed state of TargetGroupPolicy.</p> Field Description <code>conditions</code>  []Kubernetes meta/v1.Condition  (Optional) <p>Conditions describe the current conditions of the AccessLogPolicy.</p> <p>Implementations should prefer to express Policy conditions using the <code>PolicyConditionType</code> and <code>PolicyConditionReason</code> constants so that operators and tools can converge on a common vocabulary to describe AccessLogPolicy state.</p> <p>Known condition types are:</p> <ul> <li>\u201cAccepted\u201d</li> <li>\u201cReady\u201d</li> </ul>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.VpcAssociationPolicySpec","title":"VpcAssociationPolicySpec","text":"<p> (Appears on:VpcAssociationPolicy) </p> <p>VpcAssociationPolicySpec defines the desired state of VpcAssociationPolicy.</p> Field Description <code>securityGroupIds</code>  []SecurityGroupId  (Optional) <p>SecurityGroupIds defines the security groups enforced on the VpcServiceNetworkAssociation. Security groups does not take effect if AssociateWithVpc is set to false.</p> <p>For more details, please check the VPC Lattice documentation https://docs.aws.amazon.com/vpc-lattice/latest/ug/security-groups.html</p> <code>associateWithVpc</code>  bool  (Optional) <p>AssociateWithVpc indicates whether the VpcServiceNetworkAssociation should be created for the current VPC of k8s cluster.</p> <p>This value will be considered true by default.</p> <code>targetRef</code>  sigs.k8s.io/gateway-api/apis/v1alpha2.PolicyTargetReference  <p>TargetRef points to the kubernetes Gateway resource that will have this policy attached.</p> <p>This field is following the guidelines of Kubernetes Gateway API policy attachment.</p>"},{"location":"api-reference/#application-networking.k8s.aws/v1alpha1.VpcAssociationPolicyStatus","title":"VpcAssociationPolicyStatus","text":"<p> (Appears on:VpcAssociationPolicy) </p> <p>VpcAssociationPolicyStatus defines the observed state of VpcAssociationPolicy.</p> Field Description <code>conditions</code>  []Kubernetes meta/v1.Condition  (Optional) <p>Conditions describe the current conditions of the VpcAssociationPolicy.</p> <p>Implementations should prefer to express Policy conditions using the <code>PolicyConditionType</code> and <code>PolicyConditionReason</code> constants so that operators and tools can converge on a common vocabulary to describe VpcAssociationPolicy state.</p> <p>Known condition types are:</p> <ul> <li>\u201cAccepted\u201d</li> </ul> <p> Generated with <code>gen-crd-api-reference-docs</code> on git commit <code>5de8f32</code>. </p>"},{"location":"conformance-test/","title":"Report on Gateway API Conformance Testing","text":"<p>Kubernetes Gateway API Conformance</p>"},{"location":"conformance-test/#summary-of-test-result","title":"Summary of Test Result","text":"Category Test Cases Status Notes GatewayClass GatewayClassObservedGenerationBump ok Gateway GatewayObservedGenerationBump ok GatewayInvalidRouteKind ok GatewayWithAttachedRoutes ok GatewaySecretInvalidReferenceGrants N/A VPC Lattice supports ACM certs GatewaySecretMissingReferenceGrant N/A VPC Lattice supports ACM certs GatewaySecretReferenceGrantAllInNamespace N/A VPC Lattice supports ACM Certs GatewaySecretReferenceGrantSpecific N/A VPC Lattice supports ACM certs HTTPRoute HTTPRouteCrossNamespace ok HTTPExactPathMatching ok HTTPRouteHeaderMatching fail Test data exceeds Lattice limit on # of rules HTTPRouteSimpleSameNamespace ok HTTPRouteListenerHostnameMatching N/A Listener hostname not supported HTTPRouteMatchingAcrossRoutes N/A Custom domain name conflict not allowed HTTPRouteMatching fail Route precedence HTTPRouteObservedGenerationBump ok HTTPRoutePathMatchOrder fail Test data exceeds Lattice limit on # of rules HTTPRouteReferenceGrant N/A HTTPRouteDisallowedKind N/A Only HTTPRoute is supported HTTPRouteInvalidNonExistentBackendRef fail #277 HTTPRouteInvalidBackendRefUnknownKind fail #277 HTTPRouteInvalidCrossNamespaceBackendRef fail #277 HTTPRouteInvalidCrossNamespaceParentRef fail #277 HTTPRouteInvalidParentRefNotMatchingListenerPort fail #277 HTTPRouteInvalidParentRefNotMatchingSectionName fail #277 HTTPRouteMethodMatching fail not supported in controller yet. #123 HTTPRouteHostnameIntersection N/A VPC lattice only supports one custom domain HTTPRouteQueryParamMatching N/A Not supported by lattice HTTPRouteRedirectHostAndStatus N/A Not supported by lattice HTTPRouteRedirectPath N/A Not supported by lattice HTTPRouteRedirectPort N/A Not supported by lattice HTTPRouteRedirectScheme N/A Not supported by lattice HTTPRouteRequestHeaderModifier N/A Not supported by lattice HTTPRouteResponseHeaderModifier N/A Not supported by lattice HTTPRouteRewriteHost N/A Not supported by lattice HTTPRouteRewritePath N/A Not supported by lattice"},{"location":"conformance-test/#running-gateway-api-conformance","title":"Running Gateway API Conformance","text":""},{"location":"conformance-test/#running-controller-from-cloud-desktop","title":"Running controller from cloud desktop","text":"<pre><code># run controller in following mode\n\nREGION=us-west-2 DEFAULT_SERVICE_NETWORK=my-cluster-default ENABLE_SERVICE_NETWORK_OVERRIDE=true \\\nmake run\n</code></pre>"},{"location":"conformance-test/#run-individual-conformance-test","title":"Run individual conformance test","text":"<p>Conformance tests directly send traffic, so they should run inside the VPC that the cluster is operating on.</p> <pre><code>go test ./conformance/ --run \"TestConformance/HTTPRouteCrossNamespace$\" -v -args -gateway-class amazon-vpc-lattice \\\n-supported-features Gateway,HTTPRoute,GatewayClassObservedGenerationBump\n</code></pre>"},{"location":"faq/","title":"Frequently Asked Questions (FAQ)","text":"<p>How can I get involved with AWS Gateway API Controller?</p> <p>We welcome general feedback, questions, feature requests, or bug reports by creating a Github issue.</p> <p>Where can I find AWS Gateway API Controller releases?</p> <p>AWS Gateway API Controller releases are tags of the Github repository. The Github releases page shows all the releases.</p> <p>Which EKS CNI versions are supported?</p> <p>Your AWS VPC CNI must be v1.8.0 or later to work with VPC Lattice.</p> <p>Which versions of Gateway API are supported?</p> <p>AWS Gateway API Controller supports Gateway API CRD bundle versions between v0.6.1 and v1.0.0. The controller does not reject other versions, but will provide \"best effort support\" to it. Not all features of Gateway API are supported - for detailed features and limitation, please refer to individual API references. By default, Gateway API v0.6.1 CRD bundle is included in the helm chart.</p>"},{"location":"api-types/access-log-policy/","title":"AccessLogPolicy API Reference","text":""},{"location":"api-types/access-log-policy/#introduction","title":"Introduction","text":"<p>The AccessLogPolicy custom resource allows you to define access logging configurations on Gateways, HTTPRoutes, and GRPCRoutes by specifying a destination for the access logs to be published to.</p>"},{"location":"api-types/access-log-policy/#features","title":"Features","text":"<ul> <li>When an AccessLogPolicy is created for a Gateway target, VPC Lattice traffic to any Route that is a child of that Gateway will have access logs published to the provided destination</li> <li>When an AccessLogPolicy is created for an HTTPRoute or GRPCRoute target, VPC Lattice traffic to that Route will have access logs published to the provided destination</li> </ul>"},{"location":"api-types/access-log-policy/#example-configurations","title":"Example Configurations","text":""},{"location":"api-types/access-log-policy/#example-1","title":"Example 1","text":"<p>This configuration results in access logs being published to the S3 Bucket, <code>my-bucket</code>, when traffic is sent to any HTTPRoute or GRPCRoute that is a child of Gateway <code>my-hotel</code>.</p> <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: AccessLogPolicy\nmetadata:\n  name: my-access-log-policy\nspec:\n  destinationArn: \"arn:aws:s3:::my-bucket\"\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: Gateway\n    name: my-hotel\n</code></pre>"},{"location":"api-types/access-log-policy/#example-2","title":"Example 2","text":"<p>This configuration results in access logs being published to the CloudWatch Log Group, <code>myloggroup</code>, when traffic is sent to HTTPRoute <code>inventory</code>.</p> <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: AccessLogPolicy\nmetadata:\n  name: my-access-log-policy\nspec:\n  destinationArn: \"arn:aws:logs:us-west-2:123456789012:log-group:myloggroup:*\"\n  targetRef:\n    group: gateway.networking.k8s.io\n    kind: HTTPRoute\n    name: inventory\n</code></pre>"},{"location":"api-types/access-log-policy/#aws-permissions-required","title":"AWS Permissions Required","text":"<p>Per the VPC Lattice documentation,  IAM permissions are required to enable access logs:</p> <pre><code>{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Sid\": \"ManageVPCLatticeAccessLogSetup\",\n            \"Action\": [\n                \"logs:CreateLogDelivery\",\n                \"logs:GetLogDelivery\",\n                \"logs:UpdateLogDelivery\",\n                \"logs:DeleteLogDelivery\",\n                \"logs:ListLogDeliveries\",\n                \"vpc-lattice:CreateAccessLogSubscription\",\n                \"vpc-lattice:GetAccessLogSubscription\",\n                \"vpc-lattice:UpdateAccessLogSubscription\",\n                \"vpc-lattice:DeleteAccessLogSubscription\",\n                \"vpc-lattice:ListAccessLogSubscriptions\"\n            ],\n            \"Resource\": [\n                \"*\"\n            ]\n        }\n    ]\n}\n</code></pre>"},{"location":"api-types/access-log-policy/#statuses","title":"Statuses","text":"<p>AccessLogPolicies fit under the definition of Gateway API Policy Objects. As a result, status conditions are applied on every modification of an AccessLogPolicy, and can be viewed by describing it.</p>"},{"location":"api-types/access-log-policy/#status-condition-reasons","title":"Status Condition Reasons","text":""},{"location":"api-types/access-log-policy/#accepted","title":"Accepted","text":"<p>The spec of the AccessLogPolicy is valid and has been accepted for reconciliation by the controller.</p>"},{"location":"api-types/access-log-policy/#conflicted","title":"Conflicted","text":"<p>The target already has an AccessLogPolicy for the same destination type (i.e. a target can have 1 AccessLogPolicy for an S3 Bucket, 1 for a CloudWatch Log Group, and 1 for a Firehose Delivery Stream at a time).</p>"},{"location":"api-types/access-log-policy/#invalid","title":"Invalid","text":"<p>Any of the following: - The target's <code>Group</code> is not <code>gateway.networking.k8s.io</code> - The target's <code>Kind</code> is not <code>Gateway</code>, <code>HTTPRoute</code>, or <code>GRPCRoute</code> - The target's namespace does not match the AccessLogPolicy's namespace</p>"},{"location":"api-types/access-log-policy/#targetnotfound","title":"TargetNotFound","text":"<p>The target does not exist.</p>"},{"location":"api-types/access-log-policy/#annotations","title":"Annotations","text":"<p>Upon successful creation or modification of an AccessLogPolicy, the controller may add or update an annotation in the AccessLogPolicy. The annotation applied by the controller has the key <code>application-networking.k8s.aws/accessLogSubscription</code>, and its value is the corresponding VPC Lattice Access Log Subscription's ARN.</p> <p>When an AccessLogPolicy's <code>destinationArn</code> is changed such that the resource type changes (e.g. from S3 Bucket to CloudWatch Log Group), or the AccessLogPolicy's <code>targetRef</code> is changed, the annotation's value will be updated because a new Access Log Subscription will be created to replace the previous one.</p> <p>When creation of an AccessLogPolicy fails, no annotation is added to the AccessLogPolicy because no corresponding Access Log Subscription exists.</p> <p>When modification or deletion of an AccessLogPolicy fails, the previous value of the annotation is left unchanged because the corresponding Access Log Subscription is also left unchanged.</p>"},{"location":"api-types/gateway/","title":"Gateway API Reference","text":""},{"location":"api-types/gateway/#introduction","title":"Introduction","text":"<p><code>Gateway</code> allows you to configure network traffic through AWS Gateway API Controller. When a Gateway is defined with <code>amazon-vpc-lattice</code> GatewayClass, the controller will watch for the gateway and the resources under them, creating required resources under Amazon VPC Lattice.</p> <p>Internally, a Gateway points to a VPC Lattice service network. Service networks are identified by Gateway name (without namespace) - for example, a Gateway named <code>my-gateway</code> will point to a VPC Lattice service network <code>my-gateway</code>. If multiple Gateways share the same name, all of them will point to the same service network.</p> <p>VPC Lattice service networks must be managed separately, as it is a broader concept that can cover resources outside the Kubernetes cluster. To create and manage a service network, you can either:</p> <ul> <li>Specify <code>DEFAULT_SERVICE_NETWORK</code> configuration option on the controller. This will make the controller   to create a service network with such name, and associate the cluster VPC to it for you. This is suitable   for simple use cases with single service network.</li> <li>Manage service networks outside the cluster, using AWS Console, CDK, CloudFormation, etc. This is recommended   for more advanced use cases that cover multiple clusters and VPCs.</li> </ul> <p>Gateways with <code>amazon-vpc-lattice</code> GatewayClass do not create a single entrypoint to bind Listeners and Routes under them. Instead, each Route will have its own domain name assigned. To see an example of how domain names are assigned, please refer to our Getting Started Guide.</p>"},{"location":"api-types/gateway/#supported-gatewayclass","title":"Supported GatewayClass","text":"<ul> <li><code>amazon-vpc-lattice</code>   This is the default GatewayClass for managing traffic using Amazon VPC Lattice.</li> </ul>"},{"location":"api-types/gateway/#limitations","title":"Limitations","text":"<ul> <li>GatewayAddress status does not represent all accessible endpoints belong to a Gateway.   Instead, you should check annotations of each Route.</li> <li>Only <code>Terminate</code> is supported for TLS mode. TLSRoute is currently not supported.</li> <li>TLS certificate cannot be provided through <code>certificateRefs</code> field by <code>Secret</code> resource.   Instead, you can create an ACM certificate and put its ARN to the <code>options</code> field.</li> </ul>"},{"location":"api-types/gateway/#example-configuration","title":"Example Configuration","text":"<p>Here is a sample configuration that demonstrates how to set up a <code>Gateway</code>:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: my-hotel\nspec:\n  gatewayClassName: amazon-vpc-lattice\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n    - name: https\n      protocol: HTTPS\n      port: 443\n      tls:\n        mode: Terminate\n        certificateRefs:\n          - name: unused\n        options:\n          application-networking.k8s.aws/certificate-arn: &lt;certificate-arn&gt;\n</code></pre> <p>The created Gateway will point to a VPC Lattice service network named <code>my-hotel</code>. Routes under this Gateway can have either <code>http</code> or <code>https</code> listener as a parent based on their desired protocol to use.</p> <p>This <code>Gateway</code> documentation provides a detailed introduction, feature set, and a basic example of how to configure and use the resource within AWS Gateway API Controller project. For in-depth details and specifications, you can refer to the official Gateway API documentation.</p>"},{"location":"api-types/grpc-route/","title":"GRPCRoute API Reference","text":""},{"location":"api-types/grpc-route/#introduction","title":"Introduction","text":"<p>With integration of the Gateway API, AWS Gateway API Controller supports <code>GRPCRoute</code>. This allows you to define and manage the routing of gRPC traffic within your Kubernetes cluster.</p>"},{"location":"api-types/grpc-route/#grpcroute-key-features-limitations","title":"GRPCRoute Key Features &amp; Limitations","text":"<p>Features:</p> <ul> <li>Routing Traffic: Enables routing gRPC traffic to servers within your Kubernetes cluster.</li> <li>Service and Method Matching: The <code>GRPCRoute</code> allows for matching by:<ul> <li>An exact gRPC service and method.</li> <li>An exact gRPC service without specifying a method.</li> <li>All gRPC services and methods.</li> </ul> </li> <li>Header Matching: Enables matching based on specific headers in the gRPC request.</li> </ul> <p>Limitations:</p> <ul> <li>Listener Protocol: The <code>GRPCRoute</code> sectionName must refer to an HTTPS listener in the parent <code>Gateway</code>.</li> <li>Service Export: The <code>GRPCRoute</code> does not support integration with <code>ServiceExport</code>.</li> <li>Method Matches: One method match is allowed within a single rule.</li> <li>Header Matches Limit: A maximum of 5 header matches per rule is supported.</li> <li>No Method Without Service: Matching only by a gRPC method without specifying a service is not supported.</li> <li>Case Insensitivity: All method matches are currently case-insensitive.</li> </ul>"},{"location":"api-types/grpc-route/#annotations","title":"Annotations","text":"<ul> <li><code>application-networking.k8s.aws/lattice-assigned-domain-name</code>   Represents a VPC Lattice generated domain name for the resource. This annotation will automatically set   when a <code>GRPCRoute</code> is programmed and ready.</li> </ul>"},{"location":"api-types/grpc-route/#example-configuration","title":"Example Configuration","text":"<p>Here is a sample configuration that demonstrates how to set up a <code>GRPCRoute</code> for a HelloWorld gRPC service:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: GRPCRoute\nmetadata:\n  name: greeter-grpc-route\nspec:\n  parentRefs:\n    - name: my-hotel\n      sectionName: https\n  rules:\n    - matches:\n        - headers:\n            - name: testKey1\n              value: testValue1\n      backendRefs:\n        - name: greeter-grpc-server\n          kind: Service\n          port: 50051\n          weight: 10\n    - matches:\n        - method:\n            service: helloworld.Greeter\n            method: SayHello\n      backendRefs:\n        - name: greeter-grpc-server\n          kind: Service\n          port: 443\n</code></pre> <p>In this example:</p> <ul> <li>The <code>GRPCRoute</code> is named <code>greeter-grpc-route</code> and is associated with a parent gateway named <code>my-hotel</code> that has   a section named <code>https</code>.</li> <li>The first routing rule is set up to forward traffic to a backend service named <code>greeter-grpc-server</code> on port <code>50051</code>.   The rule also specifies a header match condition, where traffic must have a header with the name <code>testKey1</code> and   value <code>testValue1</code> for the routing rule to apply.</li> <li>The second rule matches gRPC traffic for the service <code>helloworld.Greeter</code> and method <code>SayHello</code>, forwarding it to   the <code>greeter-grpc-server</code> on port <code>443</code>.</li> </ul> <p>This <code>GRPCRoute</code> documentation provides a detailed introduction, feature set, and a basic example of how to configure and use the resource within AWS Gateway API Controller project. For in-depth details and specifications, you can refer to the official Gateway API documentation.</p>"},{"location":"api-types/http-route/","title":"HTTPRoute API Reference","text":""},{"location":"api-types/http-route/#introduction","title":"Introduction","text":"<p>With integration of the Gateway API, AWS Gateway API Controller supports <code>HTTPRoute</code>. This allows you to define and manage the routing of HTTP and HTTPS traffic within your Kubernetes cluster.</p>"},{"location":"api-types/http-route/#httproute-key-features-limitations","title":"HTTPRoute Key Features &amp; Limitations","text":"<p>Features:</p> <ul> <li>Routing Traffic: Enables routing HTTP traffic to servers within your Kubernetes cluster.</li> <li>Path and Method Matching: The <code>HTTPRoute</code> allows for matching by:<ul> <li>An exact path.</li> <li>Any path with a specified prefix.</li> <li>A specific HTTP Method.</li> </ul> </li> <li>Header Matching: Enables matching based on specific headers in the HTTP request.</li> </ul> <p>Limitations:</p> <ul> <li>Listener Protocol: The <code>HTTPRoute</code> sectionName must refer to an HTTP or HTTPS listener in the parent <code>Gateway</code>.</li> <li>Method Matches: One method match is allowed within a single rule.</li> <li>QueryParam Matches: Matching by QueryParameters is not supported.</li> <li>Header Matches Limit: A maximum of 5 header matches per rule is supported.</li> <li>Case Insensitivity: All path matches are currently case-insensitive.</li> </ul>"},{"location":"api-types/http-route/#annotations","title":"Annotations","text":"<ul> <li><code>application-networking.k8s.aws/lattice-assigned-domain-name</code>   Represents a VPC Lattice generated domain name for the resource. This annotation will automatically set   when a <code>HTTPRoute</code> is programmed and ready.</li> </ul>"},{"location":"api-types/http-route/#example-configuration","title":"Example Configuration","text":""},{"location":"api-types/http-route/#example-1","title":"Example 1","text":"<p>Here is a sample configuration that demonstrates how to set up an <code>HTTPRoute</code> that forwards HTTP traffic to a Service and ServiceImport, using rules to determine which backendRef to route traffic to.</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: inventory\nspec:\n  parentRefs:\n    - name: my-hotel\n      sectionName: http\n  rules:\n    - backendRefs:\n        - name: inventory-ver1\n          kind: Service\n          port: 80\n      matches:\n        - path:\n            type: PathPrefix\n            value: /ver1\n    - backendRefs:\n        - name: inventory-ver2\n          kind: ServiceImport\n          port: 80\n      matches:\n        - path:\n            type: PathPrefix\n            value: /ver2\n</code></pre> <p>In this example:</p> <ul> <li>The <code>HTTPRoute</code> is named <code>inventory</code> and is associated with a parent gateway named <code>my-hotel</code> that has   a section named <code>http</code>.</li> <li>The first routing rule forwards traffic to a backend Service named <code>inventory-ver1</code> on port <code>80</code>.   The rule also specifies a path match condition, where traffic must have a path starting with <code>/ver1</code> for the routing   rule to apply.</li> <li>The second routing rule forwards traffic to a backend ServiceImport named <code>inventory-ver2</code> on port <code>80</code>.   The rule also specifies a path match condition, where traffic must have a path starting with <code>/ver2</code> for the routing   rule to apply.</li> </ul>"},{"location":"api-types/http-route/#example-2","title":"Example 2","text":"<p>Here is a sample configuration that demonstrates how to set up a <code>HTTPRoute</code> that forwards HTTP and HTTPS traffic to a Service and ServiceImport, using weighted rules to route more traffic to one backendRef than the other. Weighted rules simplify the process of creating blue/green deployments by shifting rule weight from one backendRef to another.</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: inventory\nspec:\n  parentRefs:\n    - name: my-hotel\n      sectionName: http\n    - name: my-hotel\n      sectionName: https\n  rules:\n    - backendRefs:\n        - name: inventory-ver1\n          kind: Service\n          port: 80\n          weight: 10\n        - name: inventory-ver2\n          kind: ServiceImport\n          port: 80\n          weight: 90\n</code></pre> <p>In this example:</p> <ul> <li>The <code>HTTPRoute</code> is named <code>inventory</code> and is associated with a parent gateway named <code>my-hotel</code> that has   two sections, named <code>http</code> and <code>https</code>.</li> <li>The first routing rule forwards traffic to a backend Service named <code>inventory-ver1</code> on port <code>80</code>.   The rule also specifies a weight of <code>10</code>.</li> <li>The second routing rule forwards traffic to a backend ServiceImport named <code>inventory-ver2</code> on port <code>80</code>.   The rule also specifies a weight of <code>90</code>.</li> <li>The amount of traffic forwarded to a backendRef is <code>(rule weight / total weight) * 100%</code>. Thus, 10% of the traffic is   forwarded to <code>inventory-ver1</code> at port <code>80</code> and 90% of the traffic is forwarded to <code>inventory-ver2</code> at the default port.</li> </ul> <p>This <code>HTTPRoute</code> documentation provides a detailed introduction, feature set, and a basic example of how to configure and use the resource within AWS Gateway API Controller project. For in-depth details and specifications, you can refer to the official Gateway API documentation.</p>"},{"location":"api-types/iam-auth-policy/","title":"IAMAuthPolicy API Reference","text":""},{"location":"api-types/iam-auth-policy/#introduction","title":"Introduction","text":"<p>VPC Lattice Auth Policies are IAM policy documents that are attached to VPC Lattice Service Networks or Services to control authorization of principal's access the attached Service Network's Services, or the specific attached Service.</p> <p>IAMAuthPolicy implements Direct Policy Attachment of Gateway APIs GEP-713: Metaresources and Policy Attachment.  An IAMAuthPolicy can be attached to a Gateway, HTTPRoute, or GRPCRoute.</p> <p>Please visit the VPC Lattice Auth Policy documentation page for more details about Auth Policies.</p>"},{"location":"api-types/iam-auth-policy/#features","title":"Features","text":"<ul> <li>Attaching a policy to a Gateway results in an AuthPolicy being applied to the Gateway's associated VPC Lattice Service Network.</li> <li>Attaching a policy to an HTTPRoute or GRPCRoute results in an AuthPolicy being applied to the Route's associated VPC Lattice Service.</li> </ul> <p>Note: IAMAuthPolicy can only do authorization for traffic that travels through Gateways, HTTPRoutes, and GRPCRoutes. The authorization will not take effect if the client directly sends traffic to the k8s service DNS.</p> <p>This article is also a good reference on how to set up VPC Lattice Auth Policies in Kubernetes.</p>"},{"location":"api-types/iam-auth-policy/#example-configuration","title":"Example Configuration","text":""},{"location":"api-types/iam-auth-policy/#example-1","title":"Example 1","text":"<p>This configuration attaches a policy to the Gateway, <code>default/my-hotel</code>. The policy only allows traffic with the header, <code>header1=value1</code>, through the Gateway. This means, for every child HTTPRoute and GRPCRoute of the Gateway, only traffic with the specified header will be authorized to access it.</p> <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: IAMAuthPolicy\nmetadata:\n    name: test-iam-auth-policy\nspec:\n    targetRef:\n        group: \"gateway.networking.k8s.io\"\n        kind: Gateway\n        name: my-hotel\n    policy: |\n        {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Principal\": \"*\",\n                    \"Action\": \"vpc-lattice-svcs:Invoke\",\n                    \"Resource\": \"*\",\n                    \"Condition\": {\n                        \"StringEquals\": {\n                            \"vpc-lattice-svcs:RequestHeader/header1\": \"value1\"\n                        }\n                    }\n                }\n            ]\n        }\n</code></pre>"},{"location":"api-types/iam-auth-policy/#example-2","title":"Example 2","text":"<p>This configuration attaches a policy to the HTTPRoute, <code>examplens/my-route</code>. The policy only allows traffic from the principal, <code>123456789012</code>, to the HTTPRoute. Note that the traffic from the specified principal must be SIGv4-signed to be authorized.</p> <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: IAMAuthPolicy\nmetadata:\n    name: test-iam-auth-policy\nspec:\n    targetRef:\n        group: \"gateway.networking.k8s.io\"\n        kind: HTTPRoute\n        namespace: examplens\n        name: my-route\n    policy: |\n        {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Effect\": \"Allow\",\n                    \"Principal\": \"123456789012\",\n                    \"Action\": \"vpc-lattice-svcs:Invoke\",\n                    \"Resource\": \"*\"\n                }\n            ]\n        }\n</code></pre>"},{"location":"api-types/service-export/","title":"ServiceExport API Reference","text":""},{"location":"api-types/service-export/#introduction","title":"Introduction","text":"<p>In AWS Gateway API Controller, <code>ServiceExport</code> enables a Service for multi-cluster traffic setup. Clusters can import the exported service with <code>ServiceImport</code> resource.</p> <p>Internally, creating a ServiceExport creates a standalone VPC Lattice target group. Even without ServiceImports, creating ServiceExports can be useful in case you only need the target groups created; for example, using target groups in the VPC Lattice setup outside Kubernetes.</p> <p>Note that ServiceExport is not the implementation of Kubernetes Multicluster Service APIs; instead AWS Gateway API Controller uses its own version of the resource for the purpose of Gateway API integration.</p>"},{"location":"api-types/service-export/#limitations","title":"Limitations","text":"<ul> <li>The exported Service can only be used in HTTPRoutes. GRPCRoute is currently not supported.</li> <li>Limited to one ServiceExport per Service. If you need multiple exports representing each port,   you should create multiple Service-ServiceExport pairs.</li> </ul>"},{"location":"api-types/service-export/#annotations","title":"Annotations","text":"<ul> <li><code>application-networking.k8s.aws/port</code>   Represents which port of the exported Service will be used.   When a comma-separated list of ports is provided, the traffic will be distributed to all ports in the list.</li> </ul>"},{"location":"api-types/service-export/#example-configuration","title":"Example Configuration","text":"<p>The following yaml will create a ServiceExport for a Service named <code>service-1</code>: <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: ServiceExport\nmetadata:\n  name: service-1\n  annotations:\n    application-networking.k8s.aws/port: \"9200\"\nspec: {}\n</code></pre></p>"},{"location":"api-types/service-import/","title":"ServiceImport API Reference","text":""},{"location":"api-types/service-import/#introduction","title":"Introduction","text":"<p><code>ServiceImport</code> is a resource referring to a Service outside the cluster, paired with <code>ServiceExport</code> resource defined in the other clusters.</p> <p>Just like Services, ServiceImports can be a backend reference of HTTPRoutes. Along with the cluster's own Services (and ServiceImports from even more clusters), you can distribute the traffic across multiple VPCs and clusters.</p> <p>Note that ServiceImport is not the implementation of Kubernetes Multicluster Service APIs; instead AWS Gateway API Controller uses its own version of the resource for the purpose of Gateway API integration.</p>"},{"location":"api-types/service-import/#limitations","title":"Limitations","text":"<ul> <li>ServiceImport shares the limitations of ServiceExport.</li> <li>The controller only supports ServiceImport through HTTPRoute; sending traffic directly is not supported.</li> <li>BackendRef ports pointing to ServiceImport is not respected. Use port annotation of ServiceExport instead.</li> </ul>"},{"location":"api-types/service-import/#annotations","title":"Annotations","text":"<ul> <li><code>application-networking.k8s.aws/aws-eks-cluster-name</code>   (Optional) When specified, the controller will only find target groups exported from the cluster.</li> <li><code>application-networking.k8s.aws/aws-vpc</code>   (Optional) When specified, the controller will only find target groups exported from the cluster with the provided VPC ID.</li> </ul>"},{"location":"api-types/service-import/#example-configuration","title":"Example Configuration","text":"<p>The following yaml imports <code>service-1</code> exported from the designated cluster. <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: ServiceImport\nmetadata:\n  name: service-1\n  annotations:\n    application-networking.k8s.aws/aws-eks-cluster-name: \"service-1-owner-cluster\"\n    application-networking.k8s.aws/aws-vpc: \"service-1-owner-vpc-id\"\nspec: {}\n</code></pre></p> <p>The following example HTTPRoute directs traffic to the above ServiceImport. <pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: my-route\nspec:\n  parentRefs:\n    - name: my-gateway\n      sectionName: http\n  rules:\n    - backendRefs:\n        - name: service-1\n          kind: ServiceImport\n</code></pre></p>"},{"location":"api-types/service/","title":"Service API Reference","text":""},{"location":"api-types/service/#introduction","title":"Introduction","text":"<p>Kubernetes Services define a logical set of Pods and a policy by which to access them, often referred to as a microservice. The set of Pods targeted by a Service is determined by a <code>selector</code>.</p>"},{"location":"api-types/service/#service-key-features-limitations","title":"Service Key Features &amp; Limitations","text":"<p>Features:</p> <ul> <li>Load Balancing: Services offer load balancing, distributing network traffic across the Pods.</li> <li>Service Types: Supports different types, such as ClusterIP (default), NodePort, LoadBalancer, and ExternalName.</li> <li>Stable IP Address: Each Service has a stable IP address, even when the Pods it routes to change.</li> </ul> <p>Limitations:</p> <ul> <li>Immutable Selector: Once a Service is created, its <code>selector</code> and <code>type</code> fields cannot be updated.</li> <li>Single Namespace: Services can only route to Pods within the same namespace.</li> <li>ExternalName Limitation: <code>ExternalName</code> type is not supported by this controller.</li> </ul>"},{"location":"api-types/service/#example-configuration","title":"Example Configuration:","text":""},{"location":"api-types/service/#example-1","title":"Example 1","text":"<p>Here's a basic example of a Service that routes traffic to Pods with the label <code>app=MyApp</code>:</p> <pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: MyApp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n</code></pre> <p>In this example:</p> <ul> <li>The Service is named <code>my-service</code>.</li> <li>It targets Pods with the label <code>app=MyApp</code>.</li> <li>The Service exposes port 80, which routes to target port 8080 on the Pods.</li> </ul> <p>This <code>Service</code> documentation provides an overview of its key features, limitations, and basic examples of configuration within Kubernetes. For detailed specifications and advanced configurations, refer to the official Kubernetes Service documentation.</p>"},{"location":"api-types/target-group-policy/","title":"TargetGroupPolicy API Reference","text":""},{"location":"api-types/target-group-policy/#introduction","title":"Introduction","text":"<p>By default, AWS Gateway API Controller assumes plaintext HTTP/1 traffic for backend Kubernetes resources. TargetGroupPolicy is a CRD that can be attached to Service or ServiceExport, which allows the users to define protocol, protocol version and health check configurations of those backend resources.</p> <p>When attaching a policy to a resource, the following restrictions apply:</p> <ul> <li>A policy can be attached to <code>Service</code> that being <code>backendRef</code> of <code>HTTPRoute</code>, <code>GRPCRoute</code> and <code>TLSRoute</code>.</li> <li>A policy can be attached to <code>ServiceExport</code>.</li> <li>The attached resource should exist in the same namespace as the policy resource.</li> </ul> <p>The policy will not take effect if: - The resource does not exist - The resource is not referenced by any route - The resource is referenced by a route of unsupported type - The ProtocolVersion is non-empty if the TargetGroupPolicy protocol is TCP</p> <p>Please check the TargetGroupPolicy API Reference for more details. TargetGroupPolicy API Reference</p> <p>These restrictions are not forced; for example, users may create a policy that targets a service that is not created yet. However, the policy will not take effect unless the target is valid.</p>"},{"location":"api-types/target-group-policy/#limitations-and-considerations","title":"Limitations and Considerations","text":"<ul> <li>Attaching TargetGroupPolicy to an existing Service that is already referenced by a route will result in a replacement   of VPC Lattice TargetGroup resource, except for health check updates.</li> <li>Attaching TargetGroupPolicy to an existing ServiceExport will result in a replacement of VPC Lattice TargetGroup resource, except for health check updates.</li> <li>Removing TargetGroupPolicy of a resource will roll back protocol configuration to default setting. (HTTP1/HTTP plaintext)</li> </ul>"},{"location":"api-types/target-group-policy/#example-configuration","title":"Example Configuration","text":"<p>This will enable HTTPS traffic between the gateway and Kubernetes service, with customized health check configuration.</p> <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: TargetGroupPolicy\nmetadata:\n    name: test-policy\nspec:\n    targetRef:\n        group: \"\"\n        kind: Service\n        name: my-parking-service\n    protocol: HTTPS\n    protocolVersion: HTTP1\n    healthCheck:\n        enabled: true\n        intervalSeconds: 5\n        timeoutSeconds: 1\n        healthyThresholdCount: 3\n        unhealthyThresholdCount: 2\n        path: \"/healthcheck\"\n        port: 80\n        protocol: HTTP\n        protocolVersion: HTTP1\n        statusMatch: \"200\"\n</code></pre>"},{"location":"api-types/tls-route/","title":"TLSRoute API Reference","text":""},{"location":"api-types/tls-route/#introduction","title":"Introduction","text":"<p>With integration of the Gateway API, AWS Gateway API Controller supports <code>TLSRoute</code>. This allows you to define and manage end-to-end TLS encrypted traffic routing to your Kubernetes clusters.</p>"},{"location":"api-types/tls-route/#considerations","title":"Considerations","text":"<ul> <li><code>TLSRoute</code> sectionName must refer to a <code>TLS</code> protocol listener with <code>mode: Passthrough</code> in the parentRefs <code>Gateway</code>.</li> <li><code>TLSRoute</code> only supports to have one rule.</li> <li><code>TLSRoute</code> does not support any rule matching condition.</li> <li>The <code>hostnames</code> field with exactly one host name is required.</li> </ul>"},{"location":"api-types/tls-route/#example-configuration","title":"Example Configuration","text":"<p>Here is a sample configuration that demonstrates how to set up  a <code>TLSRoute</code> resource to route end-to-end TLS encrypted traffic to a nginx service:</p> <pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: TLSRoute\nmetadata:\n  name: nginx-tls-route\nspec:\n  hostnames:\n    - nginx-test.my-test.com\n  parentRefs:\n    - name: my-hotel-tls-passthrough\n      sectionName: tls\n  rules:\n    - backendRefs:\n        - name: nginx-tls\n          kind: Service\n          port: 443\n</code></pre> <p>In this example:</p> <ul> <li>The <code>TLSRoute</code> is named <code>nginx-tls-route</code> and is associated with a parent gateway named <code>my-hotel-tls-passthrough</code> that has   a listener section named <code>tls</code>: <pre><code>    - name: tls\n      protocol: TLS\n      port: 443\n      tls:\n        mode: Passthrough\n</code></pre></li> <li>The <code>TLSRoute</code> is configured to route traffic to a k8s service named <code>nginx-tls</code> on port 443.</li> <li>The <code>hostnames</code> field is set to <code>nginx-test.my-test.com</code>. The customer must use this hostname to send traffic to the nginx service.</li> </ul> <p>For the detailed tls passthrough traffic connectivity setup, please refer the user guide here.</p> <p>For the detailed Gateway API <code>TLSRoute</code> resource specifications, you can refer to the Kubernetes official documentation.</p> <p>For the VPC Lattice tls passthrough Listener configuration details, you can refer to the VPC Lattice documentation.</p>"},{"location":"api-types/vpc-association-policy/","title":"VpcAssociationPolicy API Reference","text":""},{"location":"api-types/vpc-association-policy/#introduction","title":"Introduction","text":"<p>VpcAssociationPolicy is a Custom Resource Definition (CRD) that can be attached to a Gateway to define the configuration of the ServiceNetworkVpcAssociation between the Gateway's associated VPC Lattice Service Network and the cluster VPC.</p>"},{"location":"api-types/vpc-association-policy/#recommended-security-group-inbound-rules","title":"Recommended Security Group Inbound Rules","text":"Source Protocol Port Range Comment Kubernetes cluster VPC CIDR or security group reference Protocols defined in the gateway's listener section Ports defined in the gateway's listener section Allow inbound traffic from current cluster vpc to gateway"},{"location":"api-types/vpc-association-policy/#limitations-and-considerations","title":"Limitations and Considerations","text":"<p>When attaching a VpcAssociationPolicy to a resource, the following restrictions apply:</p> <ul> <li>Policies must be attached to Gateway resource.</li> <li>The attached resource must exist in the same namespace as the policy resource.</li> </ul> <p>The security group will not take effect if:</p> <ul> <li>The <code>targetRef</code> gateway does not exist.</li> <li>The <code>associateWithVpc</code> field is set to false.</li> </ul>"},{"location":"api-types/vpc-association-policy/#removing-security-groups","title":"Removing Security Groups","text":"<p>The VPC Lattice <code>UpdateServiceNetworkVpcAssociation</code> API cannot be used to remove all security groups. If you have a VpcAssociationPolicy attached to a gateway that already has security groups applied, updating the VpcAssociationPolicy with empty security group ids or deleting the VpcAssociationPolicy will NOT remove the security groups from the gateway.</p> <p>To remove security groups, instead, you should delete VPC Association and re-create a new VPC Association without security group ids by following steps: 1. Update the VpcAssociationPolicy by setting <code>associateWithVpc</code> to false and empty security group ids. 2. Update the VpcAssociationPolicy by setting <code>associateWithVpc</code> to true and empty security group ids. <code>Note: Setting</code>associateWithVpc` to false will disable traffic from the current cluster workloads to the gateway.</p>"},{"location":"api-types/vpc-association-policy/#example-configuration","title":"Example Configuration","text":"<p>This configuration attaches a policy to the Gateway, <code>default/my-hotel</code>. The ServiceNetworkVpcAssociation between the Gateway's corresponding VPC Lattice Service Network and the cluster VPC is updated based on the policy contents.</p> <p>If the expected ServiceNetworkVpcAssociation does not exist, it is created since <code>associateWithVpc</code> is set to <code>true</code>. This allows traffic from clients in the cluster VPC to VPC Lattice Services in the associated Service Network. Additionally, two security groups (<code>sg-1234567890</code> and <code>sg-0987654321</code>) are attached to the ServiceNetworkVpcAssociation.</p> <pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: VpcAssociationPolicy\nmetadata:\n    name: test-vpc-association-policy\nspec:\n    targetRef:\n        group: \"gateway.networking.k8s.io\"\n        kind: Gateway\n        name: my-hotel\n    securityGroupIds:\n        - sg-1234567890\n        - sg-0987654321\n    associateWithVpc: true\n</code></pre>"},{"location":"concepts/concepts/","title":"AWS Gateway API Controller User Guide","text":"<p>As part of the VPC Lattice launch, AWS introduced the AWS Gateway API Controller ; an implementation of the Kubernetes Gateway API. Gateway API is an open-source standard interface to enable Kubernetes application networking through expressive, extensible, and role-oriented interfaces. AWS Gateway API controller extends custom resources, defined by Gateway API, which allows you to create VPC Lattice resources using Kubernetes APIs.</p> <p>When installed in your cluster, the controller watches for the creation of Gateway API resources such as gateways and routes and provisions corresponding Amazon VPC Lattice objects. This enables users to configure VPC Lattice Services, VPC Lattice service networks and Target Groups using Kubernetes APIs, without needing to write custom code or manage sidecar proxies. The AWS Gateway API Controller is an open-source project and fully supported by Amazon.</p> <p>AWS Gateway API Controller integrates with Amazon VPC Lattice and allows you to:</p> <ul> <li>Handle network connectivity seamlessly between services across VPCs and accounts.</li> <li>Discover VPC Lattice services spanning multiple Kubernetes clusters.</li> <li>Implement a defense-in-depth strategy to secure communication between those services.</li> <li>Observe the request/response traffic across the services.</li> </ul> <p>This documentation describes how to set up the AWS Gateway API Controller, provides example use cases, development concepts, and API references. AWS Gateway API Controller will provide developers the ability to publish services running on Kubernetes cluster and other compute platforms on AWS such as AWS Lambda or Amazon EC2. Once the AWS Gateway API controller deployed and running, you will be able to manage services for multiple Kubernetes clusters and other compute targets on AWS through the following:</p> <ul> <li>CLI: Use <code>aws</code> and <code>eksctl</code> to create clusters and set up AWS policies. Then use <code>kubectl</code> and YAML files to set up Kubernetes objects.</li> <li>AWS Console: View VPC Lattice assets through the VPC area of the AWS console.</li> </ul> <p>Integrating with the Kubernetes Gateway API provides a kubernetes-native experience for developers to create services, manage network routing and traffic behaviour without the heavy lifting managing the underlying networking infrastrcuture. This lets you work with Kubernetes service-related resources using Kubernetes APIs and custom resource definitions (CRDs) defined by the Kubernetes networking.k8s.io specification.</p> <p>For more information on this technology, see Kubernetes Gateway API. </p>"},{"location":"concepts/overview/","title":"Understanding the Gateway API Controller","text":"<p>For medium and large-scale customers, applications can often spread across multiple areas of a cloud. For example, information pertaining to a company\u2019s authentication, billing, and inventory may each be served by services running on different VPCs in AWS. Someone wanting to run an application that is spread out in this way might find themselves having to work with multiple ways to configure:</p> <ul> <li>Authentication and Authorization</li> <li>Observability</li> <li>Service Discovery</li> <li>Network connectivity and traffic routing</li> </ul> <p>This is not a new problem. A common approach to interconnecting services that span multiple VPCs is to use service meshes. However, these require sidecars, which can introduce scaling problems and present their own management challenges, such as dealing with control plane and data plane at scale.</p> <p>If you just want to run an application, you should be shielded from details needed to find assets across multiple VPCs and multiple clusters. You should also have consistent ways of working with assets across your VPCs, even if those assets include different combinations of instances, clusters, containers, and serverless. And while making it simpler to run multi-VPC applications easier for users, administrators still need the tools to control and audit their resources to suit their company\u2019s compliance needs.</p>"},{"location":"concepts/overview/#service-directory-networks-policies-and-gateways","title":"Service Directory, Networks, Policies and Gateways","text":"<p>The goal of VPC Lattice is to provide a way to have a single, overarching services view of all services across multiple VPCs. You should also have consistent ways of working with assets across your VPCs, even if those assets include different combinations of instances, clusters, containers, and serverless. The components making up that view include:</p> <p>Service</p> <p>An independently deployable unit of software that delivers a specific task or function. A service can run on EC2 instances or ECS containers, or as Lambda functions, within an account or a virtual private cloud (VPC). </p> A VPC Lattice service has the following components: target groups, listeners, and rules. <p>Service Network</p> <p>A logical boundary for a collection of services. A client is any resource deployed in a VPC that is associated with the service network. Clients and services that are associated with the same service network can communicate with each other if they are authorized to do so.</p> In the following figure, the clients can communicate with both services, because the VPC and services are associated with the same service network. <p>Service Directory A central registry of all VPC Lattice services that you own or are shared with your account through AWS Resource Access Manager (AWS RAM).</p> <p>Auth Policies Fine-grained authorization policies that can be used to define access to services. You can attach separate authorization policies to individual services or to the service network. For example, you can create a policy for how a payment service running on an auto scaling group of EC2 instances should interact with a billing service running in AWS Lambda.</p>"},{"location":"concepts/overview/#use-cases","title":"Use-cases","text":"<p>In the context of Kubernetes, Amazon VPC Lattice helps to simplify the following:</p> <ul> <li>Kubernetes multi-cluster connectivity: Architecting multiple clusters across multiple VPCs.   After configuring your services with the AWS Gateway API Controller, you can facilitate advanced traffic management and application layer routing between services on those clusters without dealing with the underlying infrastructure.   VPC Lattice handles a lot of the details for you without needing things like sidecars.</li> <li>Cross-platform access: VPC Lattice allows access to serverless and Amazon EC2 features, as well as Kubernetes cluster features.   This gives you a way to have a consistent interface to multiple types of platforms.</li> <li>Implement a defense-in-depth strategy: Secure communication between services and networks.</li> <li>Observe the request/response traffic across the services.</li> </ul> <p>With VPC Lattice you can also avoid some of these common problems:</p> <ul> <li>Overlapping IP addresses: Even with well-managed IP addresses, overlapping address use can occur by mistake or when organizations or companies merge together.   IP address conflicts can also occur if you wanted to manage resources across multiple Kubernetes clusters.</li> <li>Sidecar management: Changes to sidecars might require those sidecars to be reconfigured or rebooted.   While this might not be a big issue for a handful of sidecars, it can be disruptive if you have thousands of pods, each with its own sidecar.</li> </ul>"},{"location":"concepts/overview/#relationship-between-vpc-lattice-and-kubernetes","title":"Relationship between VPC Lattice and Kubernetes","text":"<p>As a Kubernetes user, you can have a very Kubernetes-native experience using the VPC Lattice APIs. The following figure illustrates how VPC Lattice objects connect to Kubernetes Gateway API objects:</p> <p>As shown in the figure, there are different personas associated with different levels of control in VPC Lattice. Notice that the Kubernetes Gateway API syntax is used to create the gateway, HTTPRoute and services, but Kubernetes gets the details of those items from VPC Lattice:</p> <ul> <li>Infrastructure provider: Creates the Kubernetes <code>GatewayClass</code> to identify VPC Lattice as the GatewayClass.</li> <li>Cluster operator: Creates the Kubernetes <code>Gateway</code>, which gets information from VPC Lattice related to the Service Gateway and service networks, as well as their related Service Policies.</li> <li>Application developer: Creates <code>HTTPRoute</code> objects that point to Kubernetes services, which in turn are directed to particular pods, in this case.</li> </ul> <p>This is all done by checking the related VPC Lattice Services (and related policies), Target Groups, and Targets.</p> <p>Keep in mind that you can have different Target Groups spread across different clusters/VPCs receiving traffic from the same VPC Lattice Service (<code>HTTPRoute</code>).</p>"},{"location":"contributing/developer-cheat-sheet/","title":"Developer Cheat Sheet","text":""},{"location":"contributing/developer-cheat-sheet/#startup","title":"Startup","text":"<p>The program flow is roughly as follows. On startup, <code>cmd/aws-application-networking-k8s/main.go#main()</code> runs. This initializes all the key components and registers various controllers (in <code>controllers/</code>) with the Kubernetes control plane. These controllers include event handlers (in <code>controllers/eventhandlers/</code>) whose basic function is to convert object notifications to more specific types and enqueue them for processing by the various controllers.</p>"},{"location":"contributing/developer-cheat-sheet/#build-and-deploy","title":"Build and Deploy","text":"<p>Processing takes place in a controller's <code>Reconcile()</code> method, which will check if the object has been changed/created or deleted. Sometimes this invokes different paths, but most involve a <code>buildAndDeployModel()</code> step.</p>"},{"location":"contributing/developer-cheat-sheet/#build","title":"Build","text":"<p>In the \"build\" step, the controller invokes a \"model builder\" with the changed Kubernetes object. Model builders (in <code>pkg/gateway/</code>) convert the Kubernetes object state into an intermediate VPC Lattice object called a \"model type\". These model types (in <code>pkg/model/lattice</code>) are basic structs which contain the important information about the source Kubernetes object and fields containing Lattice-related values. These models are built only using information from Kubernetes and are intended to contain all details needed to make updates against the VPC Lattice API. Once created, model ojbects are stored in a \"stack\" (<code>/pkg/model/core/stack.go</code>). The stack contains basic methods for storing and retrieving objects based on model type.</p>"},{"location":"contributing/developer-cheat-sheet/#deploy","title":"Deploy","text":"<p>Once the \"stack\" is populated, it is serialized for logging then passed to the \"deploy\" step. Here, a \"deployer\" (<code>/pkg/deployer/stack_deployer.go</code>) will invoke a number of \"synthesizers\" (in <code>/pkg/deploy/lattice/</code>) to read model objects from the stack and convert these to VPC Lattice API calls (via <code>Synthesize()</code>). Most synthesizer interaction with the Lattice APIs is deferred to various \"managers\" (also <code>/pkg/deploy/lattice</code>). These managers each have their own interface definition with CRUD methods that bridge model types and Lattice API types. Managers, in turn, use <code>/pkg/aws/services/vpclattice.go</code> for convenience methods against the Lattice API only using Lattice API types.</p>"},{"location":"contributing/developer-cheat-sheet/#other-notes","title":"Other notes","text":"<p>Model Status Structs On each model type is a <code>&lt;Type&gt;Status</code> struct which contains information about the object from the Lattice API, such as ARNs or IDs. These are populated either on creation against the Lattice API or in cases where the API object already exists but needs updating via the model. <p>Resource Cleanup A typical part of model synthesis (though it is also present in ) is checking all resources in the VPC Lattice API to see if they belong to deleted or missing Kubernetes resources. This is to help ensure Lattice resources are not leaked due to bugs in the reconciliation process.</p>"},{"location":"contributing/developer-cheat-sheet/#code-consistency","title":"Code Consistency","text":"<p>To help reduce cognitive load while working through the code, it is critical to be consistent. For now, this applies most directly to imports and variable naming.</p>"},{"location":"contributing/developer-cheat-sheet/#imports","title":"Imports","text":"<p>Common imports should all use the same alias (or lack of alias) so that when we see <code>aws.</code> or <code>vpclattice.</code> or <code>sdk.</code> in the code we know what they refer to without having to double-check. Here are the conventions:</p> <pre><code>import (\n  \"github.com/aws/aws-sdk-go/service/vpclattice\" // no alias\n  \"github.com/aws/aws-sdk-go/aws\" // no alias\n\n  corev1 \"k8s.io/api/core/v1\"\n  gwv1beta1 \"sigs.k8s.io/gateway-api/apis/v1beta1\"\n  ctrl \"sigs.k8s.io/controller-runtime\"\n\n  pkg_aws \"github.com/aws/aws-application-networking-k8s/pkg/aws\"\n  model \"github.com/aws/aws-application-networking-k8s/pkg/model/lattice\"\n  anv1alpha1 \"github.com/aws/aws-application-networking-k8s/pkg/apis/applicationnetworking/v1alpha1\"\n)\n</code></pre> <p>For unit tests, this changes slightly for more readability when using the imports strictly for mocking <pre><code>import (\n  mocks_aws \"github.com/aws/aws-application-networking-k8s/pkg/aws\"\n  mocks \"github.com/aws/aws-application-networking-k8s/pkg/aws/services\"\n  mock_client \"github.com/aws/aws-application-networking-k8s/mocks/controller-runtime/client\"\n)\n</code></pre></p>"},{"location":"contributing/developer-cheat-sheet/#service-service-or-service","title":"Service, Service, or Service?","text":"<p>Similarly, because there is overlap between the Gateway API spec, model types, and Lattice API nouns, it is important to use differentiating names between the types in components where the name could be ambiguous. The safest approach is to use a prefix:</p> <ul> <li><code>k8s</code> refers to a kubernetes object</li> <li><code>model</code> refers to an intermediate model object</li> <li><code>lattice</code> refers to an object from the Lattice API</li> </ul> <p>An example in practice would be</p> <pre><code>  var k8sSvc *corev1.Service\n  var modelSvc *model.Service\n  var latticeSvc *vpclattice.ServiceSummary\n</code></pre> <p>There are some objects which interact unambiguously with an underlying type, for example in <code>vpclattice.go</code> the types are always VPC Lattice API types, so disambiguating is less important there.</p>"},{"location":"contributing/developer/","title":"Developer Guide","text":""},{"location":"contributing/developer/#prerequisites","title":"Prerequisites","text":"<p>Tools</p> <p>Install these tools before proceeding:</p> <ol> <li>AWS CLI,</li> <li><code>kubectl</code> - the Kubernetes CLI,</li> <li><code>helm</code> - the package manager for Kubernetes,</li> <li><code>eksctl</code>- the CLI for Amazon EKS,</li> <li><code>go v1.20.x</code> - language,</li> <li><code>yq</code> - CLI to manipulate yaml files,</li> <li><code>jq</code> - CLI to manipulate json files,</li> <li><code>make</code>- build automation tool. </li> </ol> <p>Cluster creation and setup</p> <p>Before proceeding to the next sections, you need to:</p> <ol> <li> <p>Create a and set up a cluster <code>dev-cluster</code> with the controller following the AWS Gateway API Controller installation guide on Amazon EKS.</p> <p>Note</p> <p>You can either install the Controller and CRDs following the steps in the installation guide or using the steps below if you prefer to create the individual CRDs.</p> </li> <li> <p>Clone the AWS Gateway API Controller repository.     <pre><code>git clone git@github.com:aws/aws-application-networking-k8s.git\ncd aws-application-networking-k8s\n</code></pre></p> </li> <li>Install dependencies with <code>toolchain.sh</code> script:     <pre><code>make toolchain\n</code></pre></li> </ol>"},{"location":"contributing/developer/#setup","title":"Setup","text":"<p>Once cluster is ready, we need to apply CRDs for <code>gateway-api</code> resources. First install core <code>gateway-api</code> CRDs:</p> v1 CRDs (latest, recommended)v1beta1 CRDs <p>Install the latest <code>v1</code> CRDs: <pre><code>kubectl apply -f config/crds/bases/k8s-gateway-v1.0.0.yaml\n</code></pre></p> <p>Note</p> <p>Note that v1 CRDs are not included in <code>deploy-*.yaml</code> and <code>helm</code> chart by default. </p> <p>Install <code>gateway-api</code> <code>v1beta1</code> CRDs. <pre><code>kubectl apply -f config/crds/bases/k8s-gateway-v0.6.1.yaml\n</code></pre></p> <p>And install additional CRDs for the controller:</p> <pre><code>kubectl apply -f config/crds/bases/externaldns.k8s.io_dnsendpoints.yaml\nkubectl apply -f config/crds/bases/gateway.networking.k8s.io_tlsroutes.yaml\nkubectl apply -f config/crds/bases/application-networking.k8s.aws_serviceexports.yaml\nkubectl apply -f config/crds/bases/application-networking.k8s.aws_serviceimports.yaml\nkubectl apply -f config/crds/bases/application-networking.k8s.aws_targetgrouppolicies.yaml\nkubectl apply -f config/crds/bases/application-networking.k8s.aws_vpcassociationpolicies.yaml\nkubectl apply -f config/crds/bases/application-networking.k8s.aws_accesslogpolicies.yaml\nkubectl apply -f config/crds/bases/application-networking.k8s.aws_iamauthpolicies.yaml\n</code></pre> <p>When e2e tests are terminated during execution, it might break clean-up stage and resources will leak. To delete dangling resources manually use cleanup script:</p> <pre><code>make e2e-clean\n</code></pre>"},{"location":"contributing/developer/#local-development","title":"Local Development","text":"<p>A minimal test of changes can be done with <code>make presubmit</code>. This command will also run on PR.</p> <pre><code>make presubmit\n</code></pre> <p>Start controller in development mode, that will point to cluster (see setup above).</p> <pre><code>// should be region of the cluster\nREGION=us-west-2 make run\n</code></pre> <p>You can explore a collection of different yaml configurations in the examples folder that can be applied to cluster.</p> <p>To run it against specific lattice service endpoint.</p> <pre><code>LATTICE_ENDPOINT=https://vpc-lattice.us-west-2.amazonaws.com/ make run\n</code></pre> <p>To easier load environment variables, if you hope to run the controller by GoLand IDE locally, you could run the <code>./scripts/load_env_variables.sh</code> And use \"EnvFile\" GoLand plugin to read the env variables from the generated <code>.env</code> file.</p>"},{"location":"contributing/developer/#end-to-end-testing","title":"End-to-End Testing","text":"<p>For larger changes it's recommended to run e2e suites on your local cluster. E2E tests require a service network named <code>test-gateway</code> with cluster VPC associated to run. You can either set up service network manually or use DEFAULT_SERVICE_NETWORK option when running controller locally. (e.g. <code>DEFAULT_SERVICE_NETWORK=test-gateway make run</code>)</p> <pre><code>REGION=us-west-2 make e2e-test\n</code></pre> <p>For the <code>RAM Share</code> test suite, which runs cross-account e2e tests, you will need a secondary AWS Account with a role that can be assumed by the primary account during test execution. You can create an IAM Role, with a Trust Policy allowing the primary account to assume it, via the AWS IAM Console.</p> <pre><code>export SECONDARY_ACCOUNT_TEST_ROLE_ARN=arn:aws:iam::000000000000:role/MyRole\nexport FOCUS=\"RAM Share\"\nREGION=us-west-2 make e2e-test\n</code></pre> <p>You can use the <code>FOCUS</code> environment variable to run some specific test cases based on filter condition. You could assign the string in the Describe(\"xxxxxx\") or It(\"xxxxxx\") to the FOCUS environment variable to run the specific test cases. <pre><code>var _ = Describe(\"HTTPRoute path matches\", func() {\n    It(\"HTTPRoute should support multiple path matches\", func() {\n        // test case body\n    })\n</code></pre></p> <p>For example, to run the test case \"HTTPRoute should support multiple path matches\", you could run the following command: <pre><code>export FOCUS=\"HTTPRoute should support multiple path matches\"\nexport REGION=us-west-2\nmake e2e-test\n</code></pre></p> <p>Conversely, you can use the <code>SKIP</code> environment variable to skip specific test cases.</p> <p>For example, to skip the same test as above, you would run the following command: <pre><code>export SKIP=\"HTTPRoute should support multiple path matches\"\n</code></pre></p> <p>For more detail on filter condition for ginkgo https://onsi.github.io/ginkgo/#focused-specs https://onsi.github.io/ginkgo/#description-based-filtering</p> <p>After all test cases running finished, in the <code>AfterSuite()</code> function, it will clean up k8s and vpc lattice resource created by current test cases running.</p>"},{"location":"contributing/developer/#documentations","title":"Documentations","text":"<p>The controller documentation is managed in <code>docs/</code> directory, and built with mkdocs. It uses mike to manage versioning. To build and verify your changes locally: <pre><code>pip install -r requirements.txt\nmake docs\n</code></pre> The website will be located in <code>site/</code> directory. You can also run a local dev-server by running <code>mike serve</code> or <code>mkdocs serve</code>.</p>"},{"location":"contributing/developer/#contributing","title":"Contributing","text":"<p>Before sending a Pull Request, you should run unit tests:</p> <pre><code>make presubmit\n</code></pre> <p>For larger, functional changes, run e2e tests: <pre><code>make e2e-test\n</code></pre></p>"},{"location":"contributing/developer/#make-docker-image","title":"Make Docker Image","text":"<pre><code>make docker-build\n</code></pre>"},{"location":"contributing/developer/#deploy-controller-inside-a-kubernetes-cluster","title":"Deploy Controller inside a Kubernetes Cluster","text":"<p>Generate <code>deploy.yaml</code></p> <pre><code>make build-deploy\n</code></pre> <p>Then follow Deploying the AWS Gateway API Controller to configure and deploy the docker image.</p>"},{"location":"guides/advanced-configurations/","title":"Advanced configurations","text":"<p>The section below covers advanced configuration techniques for installing and using the AWS Gateway API Controller. This includes things such as running the controller on a self-hosted cluster on AWS or using an IPv6 EKS cluster.</p>"},{"location":"guides/advanced-configurations/#using-a-self-managed-kubernetes-cluster","title":"Using a self-managed Kubernetes cluster","text":"<p>You can install AWS Gateway API Controller to a self-managed Kubernetes cluster in AWS.</p> <p>However, the controller utilizes IMDS to get necessary information from instance metadata, such as AWS account ID and VPC ID. So:</p> <ul> <li> <p>If your cluster is using IMDSv2. ensure the hop limit is 2 or higher to allow the access from the controller:</p> <pre><code>aws ec2 modify-instance-metadata-options --http-put-response-hop-limit 2 --region &lt;region&gt; --instance-id &lt;instance-id&gt;\n</code></pre> </li> <li> <p>If your cluster cannot access to IMDS. ensure to specify theconfiguration variables when installing the controller.</p> </li> </ul>"},{"location":"guides/advanced-configurations/#ipv6-support","title":"IPv6 support","text":"<p>IPv6 address type is automatically used for your services and pods if your cluster is configured to use IPv6 addresses.</p> <p>If your cluster is configured to be dual-stack, you can set the IP address type of your service using the <code>ipFamilies</code> field. For example:</p> parking_service.yaml<pre><code>apiVersion: v1\nkind: Service\nmetadata:\n  name: ipv4-target-in-dual-stack-cluster\nspec:\n  ipFamilies:\n    - \"IPv4\"\n  selector:\n    app: parking\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8090\n</code></pre>"},{"location":"guides/custom-domain-name/","title":"Configure a Custom Domain Name for HTTPRoute","text":"<p>When you create a HTTPRoute under <code>amazon-vpc-lattice</code> gatewayclass, the controller creates a AWS VPC Lattice Service during reconciliation. VPC Lattice generates a unique Fully Qualified Domain Name (FQDN) for you; however, this auto-generated domain name is not easy to remember.</p> <p>If you'd prefer to use a custom domain name for a HTTPRoute, you can specify them in hostname field of HTTPRoute. Here is one example:</p> custom-domain-route.yaml<pre><code>apiVersion: gateway.networking.k8s.io/v1alpha2\nkind: HTTPRoute\nmetadata:\n  name: review\nspec:\n  hostnames:\n  - review.my-test.com  # this is the custom domain name\n  parentRefs:\n  - name: my-hotel\n    sectionName: http\n  rules:    \n  - backendRefs:\n    - name: review2\n      kind: Service\n      port: 8090\n    matches:\n    - path:\n        type: PathPrefix\n        value: /review2\n</code></pre>"},{"location":"guides/custom-domain-name/#managing-dns-records-using-externaldns","title":"Managing DNS records using ExternalDNS","text":"<p>To register custom domain names to your DNS provider, we recommend using ExternalDNS. AWS Gateway API Controller supports ExternalDNS integration through CRD source - the controller will manage <code>DNSEndpoint</code> resource for you. </p> <p>To use ExternalDNS with the AWS Gateway API Controller, you need to:</p> <ol> <li> <p>Install <code>DNSEndpoint</code> CRD. This is bundled with both Gateway API Controller Helm chart and <code>files/controller-installation/deploy-*.yaml</code> manifest, but also can be installed manually by the following command:    <pre><code>kubectl apply -f config/crds/bases/externaldns.k8s.io_dnsendpoints.yaml\n</code></pre></p> <p>Note</p> <p>If the <code>DNSEndpoint</code> CRD does not exist, <code>DNSEndpoint</code> resource will not be created nor will be managed by the controller.</p> </li> <li> <p>Restart the controller if running already.</p> </li> <li>Run ExternalDNS controller watching <code>crd</code> source.     The following example command runs ExternalDNS compiled from source, using AWS Route53 provider:    <pre><code>build/external-dns --source crd --crd-source-apiversion externaldns.k8s.io/v1alpha1 \\\n--crd-source-kind DNSEndpoint --provider aws --txt-prefix \"prefix.\"\n</code></pre></li> <li>Create HTTPRoutes and Services. The controller should create <code>DNSEndpoint</code> resource owned by the HTTPRoute you created.</li> <li>ExternalDNS will watch the changes and create DNS record on the configured DNS provider.</li> </ol>"},{"location":"guides/custom-domain-name/#notes","title":"Notes","text":"<ul> <li>You MUST have a registered hosted zone (e.g. <code>my-test.com</code>) in Route53 and complete the <code>Prerequisites</code> mentioned in this section of the Amazon VPC Lattice documentation.</li> <li>If you are not using ExternalDNS, you should manually associate your custom domain name with your service following this section of the Amazon VPC Lattice documentation.</li> </ul>"},{"location":"guides/deploy/","title":"Deploy the AWS Gateway API Controller on Amazon EKS","text":"<p>This Deployment Guide provides an end-to-end procedure to install the AWS Gateway API Controller with Amazon Elastic Kubernetes Service. </p> <p>Amazon EKS is a simple, recommended way of preparing a cluster for running services with AWS Gateway API Controller, however the AWS Gateway API Controller can be used on any Kubernetes cluster on AWS. Check out the Advanced Configurations section below for instructions on how to install and run the controller on self-hosted Kubernetes clusters on AWS.</p>"},{"location":"guides/deploy/#prerequisites","title":"Prerequisites","text":"<p>Install these tools before proceeding:</p> <ol> <li>AWS CLI,</li> <li><code>kubectl</code> - the Kubernetes CLI,</li> <li><code>helm</code> - the package manager for Kubernetes,</li> <li><code>eksctl</code>- the CLI for Amazon EKS,</li> <li><code>jq</code> - CLI to manipulate json files.</li> </ol>"},{"location":"guides/deploy/#setup","title":"Setup","text":"<p>Set your AWS Region and Cluster Name as environment variables. See the Amazon VPC Lattice FAQs for a list of supported regions.    <pre><code>export AWS_REGION=&lt;cluster_region&gt;\nexport CLUSTER_NAME=&lt;cluster_name&gt;\n</code></pre></p> <p>Create a cluster (optional)</p> <p>You can easily create a cluster with <code>eksctl</code>, the CLI for Amazon EKS:    <pre><code>eksctl create cluster --name $CLUSTER_NAME --region $AWS_REGION\n</code></pre></p> <p>Allow traffic from Amazon VPC Lattice</p> <p>You must set up security groups so that they allow all Pods communicating with VPC Lattice to allow traffic from the VPC Lattice managed prefix lists.  See Control traffic to resources using security groups for details. Lattice has both an IPv4 and IPv6 prefix lists available.</p> <ol> <li> <p>Configure the EKS nodes' security group to receive traffic from the VPC Lattice network. </p> <pre><code>CLUSTER_SG=&lt;your_node_security_group&gt;\n</code></pre> <p>Note</p> <p>If you have created the cluster with <code>eksctl create cluster --name $CLUSTER_NAME --region $AWS_REGION</code> command, you can use this command to export the Security Group ID:</p> <pre><code>CLUSTER_SG=$(aws eks describe-cluster --name $CLUSTER_NAME --output json| jq -r '.cluster.resourcesVpcConfig.clusterSecurityGroupId')\n</code></pre> <pre><code>PREFIX_LIST_ID=$(aws ec2 describe-managed-prefix-lists --query \"PrefixLists[?PrefixListName==\"\\'com.amazonaws.$AWS_REGION.vpc-lattice\\'\"].PrefixListId\" | jq -r '.[]')\naws ec2 authorize-security-group-ingress --group-id $CLUSTER_SG --ip-permissions \"PrefixListIds=[{PrefixListId=${PREFIX_LIST_ID}}],IpProtocol=-1\"\nPREFIX_LIST_ID_IPV6=$(aws ec2 describe-managed-prefix-lists --query \"PrefixLists[?PrefixListName==\"\\'com.amazonaws.$AWS_REGION.ipv6.vpc-lattice\\'\"].PrefixListId\" | jq -r '.[]')\naws ec2 authorize-security-group-ingress --group-id $CLUSTER_SG --ip-permissions \"PrefixListIds=[{PrefixListId=${PREFIX_LIST_ID_IPV6}}],IpProtocol=-1\"\n</code></pre> </li> </ol> <p>Set up IAM permissions</p> <p>The AWS Gateway API Controller needs to have necessary permissions to operate.</p> <ol> <li> <p>Create a policy (<code>recommended-inline-policy.json</code>) in IAM with the following content that can invoke the Gateway API and copy the policy arn for later use:</p> <pre><code>curl https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/recommended-inline-policy.json  -o recommended-inline-policy.json\n\naws iam create-policy \\\n    --policy-name VPCLatticeControllerIAMPolicy \\\n    --policy-document file://recommended-inline-policy.json\n\nexport VPCLatticeControllerIAMPolicyArn=$(aws iam list-policies --query 'Policies[?PolicyName==`VPCLatticeControllerIAMPolicy`].Arn' --output text)\n</code></pre> </li> <li> <p>Create the <code>aws-application-networking-system</code> namespace: <pre><code>kubectl apply -f https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/deploy-namesystem.yaml\n</code></pre></p> </li> </ol> <p>You can choose from Pod Identities (recommended) and IAM Roles For Service Accounts to set up controller permissions.</p> Pod Identities (recommended)IRSA <p>Set up the Pod Identities Agent</p> <p>To use Pod Identities, we need to set up the Agent and to configure the controller's Kubernetes Service Account to assume necessary permissions with EKS Pod Identity.</p> <p>Read if you are using a custom node role</p> <p>The node role needs to have permissions for the Pod Identity Agent to do the <code>AssumeRoleForPodIdentity</code> action in the EKS Auth API. Follow the documentation if you are not using the AWS managed policy AmazonEKSWorkerNodePolicy.</p> <ol> <li>Run the following AWS CLI command to create the Pod Identity addon. <pre><code>aws eks create-addon --cluster-name $CLUSTER_NAME --addon-name eks-pod-identity-agent --addon-version v1.0.0-eksbuild.1\n</code></pre> <pre><code>kubectl get pods -n kube-system | grep 'eks-pod-identity-agent'\n</code></pre></li> </ol> <p>Assign role to Service Account</p> <p>Create an IAM role and associate it with a Kubernetes service account.</p> <ol> <li> <p>Create a Service Account.</p> <pre><code>cat &gt;gateway-api-controller-service-account.yaml &lt;&lt;EOF\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n    name: gateway-api-controller\n    namespace: aws-application-networking-system\nEOF\nkubectl apply -f gateway-api-controller-service-account.yaml\n</code></pre> </li> <li> <p>Create a trust policy file for the IAM role.</p> <pre><code>cat &gt;trust-relationship.json &lt;&lt;EOF\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Sid\": \"AllowEksAuthToAssumeRoleForPodIdentity\",\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Service\": \"pods.eks.amazonaws.com\"\n            },\n            \"Action\": [\n                \"sts:AssumeRole\",\n                \"sts:TagSession\"\n            ]\n        }\n    ]\n}\nEOF\n</code></pre> </li> <li> <p>Create the role.</p> <pre><code>aws iam create-role --role-name VPCLatticeControllerIAMRole --assume-role-policy-document file://trust-relationship.json --description \"IAM Role for AWS Gateway API Controller for VPC Lattice\"\naws iam attach-role-policy --role-name VPCLatticeControllerIAMRole --policy-arn=$VPCLatticeControllerIAMPolicyArn\nexport VPCLatticeControllerIAMRoleArn=$(aws iam list-roles --query 'Roles[?RoleName==`VPCLatticeControllerIAMRole`].Arn' --output text)\n</code></pre> </li> <li> <p>Create the association</p> <pre><code>aws eks create-pod-identity-association --cluster-name $CLUSTER_NAME --role-arn $VPCLatticeControllerIAMRoleArn --namespace aws-application-networking-system --service-account gateway-api-controller\n</code></pre> </li> </ol> <p>You can use AWS IAM Roles for Service Accounts (IRSA) to assign the Controller necessary permissions via a ServiceAccount.</p> <ol> <li> <p>Create an IAM OIDC provider: See Creating an IAM OIDC provider for your cluster for details.     <pre><code>eksctl utils associate-iam-oidc-provider --cluster $CLUSTER_NAME --approve --region $AWS_REGION\n</code></pre></p> </li> <li> <p>Create an iamserviceaccount for pod level permission:</p> <pre><code>eksctl create iamserviceaccount \\\n    --cluster=$CLUSTER_NAME \\\n    --namespace=aws-application-networking-system \\\n    --name=gateway-api-controller \\\n    --attach-policy-arn=$VPCLatticeControllerIAMPolicyArn \\\n    --override-existing-serviceaccounts \\\n    --region $AWS_REGION \\\n    --approve\n</code></pre> </li> </ol>"},{"location":"guides/deploy/#install-the-controller","title":"Install the Controller","text":"<ol> <li> <p>Run either <code>kubectl</code> or <code>helm</code> to deploy the controller. Check Environment Variables for detailed explanation of each configuration option.</p> HelmKubectl <pre><code># login to ECR\naws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws\n# Run helm with either install or upgrade\nhelm install gateway-api-controller \\\n    oci://public.ecr.aws/aws-application-networking-k8s/aws-gateway-controller-chart \\\n    --version=v1.0.6 \\\n    --set=serviceAccount.create=false \\\n    --namespace aws-application-networking-system \\\n    --set=log.level=info # use \"debug\" for debug level logs\n</code></pre> <pre><code>kubectl apply -f https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/deploy-v1.0.6.yaml\n</code></pre> </li> <li> <p>Create the <code>amazon-vpc-lattice</code> GatewayClass:    <pre><code>kubectl apply -f https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/gatewayclass.yaml\n</code></pre></p> </li> </ol>"},{"location":"guides/environment/","title":"Configuration","text":""},{"location":"guides/environment/#environment-variables","title":"Environment Variables","text":"<p>AWS Gateway API Controller for VPC Lattice supports a number of configuration options, which are set through environment variables. The following environment variables are available, and all of them are optional.</p>"},{"location":"guides/environment/#cluster_name","title":"<code>CLUSTER_NAME</code>","text":"<p>Type: string</p> <p>Default: Inferred from IMDS metadata</p> <p>A unique name to identify a cluster. This will be used in AWS resource tags to record ownership. This variable is required except for EKS cluster. This needs to be specified if IMDS is not available.</p>"},{"location":"guides/environment/#cluster_vpc_id","title":"<code>CLUSTER_VPC_ID</code>","text":"<p>Type: string</p> <p>Default: Inferred from IMDS metadata</p> <p>When running AWS Gateway API Controller outside the Kubernetes Cluster, this specifies the VPC of the cluster. This needs to be specified if IMDS is not available.</p>"},{"location":"guides/environment/#aws_account_id","title":"<code>AWS_ACCOUNT_ID</code>","text":"<p>Type: string</p> <p>Default: Inferred from IMDS metadata</p> <p>When running AWS Gateway API Controller outside the Kubernetes Cluster, this specifies the AWS account. This needs to be specified if IMDS is not available.</p>"},{"location":"guides/environment/#region","title":"<code>REGION</code>","text":"<p>Type: string</p> <p>Default: Inferred from IMDS metadata</p> <p>When running AWS Gateway API Controller outside the Kubernetes Cluster, this specifies the AWS Region of VPC Lattice Service endpoint. This needs to be specified if IMDS is not available.</p>"},{"location":"guides/environment/#log_level","title":"<code>LOG_LEVEL</code>","text":"<p>Type: string</p> <p>Default: \"info\"</p> <p>When set as \"debug\", the AWS Gateway API Controller will emit debug level logs.</p>"},{"location":"guides/environment/#default_service_network","title":"<code>DEFAULT_SERVICE_NETWORK</code>","text":"<p>Type: string</p> <p>Default: \"\"</p> <p>When set as a non-empty value, creates a service network with that name. The created service network will be also associated with cluster VPC.</p>"},{"location":"guides/environment/#enable_service_network_override","title":"<code>ENABLE_SERVICE_NETWORK_OVERRIDE</code>","text":"<p>Type: string</p> <p>Default: \"\"</p> <p>When set as \"true\", the controller will run in \"single service network\" mode that will override all gateways to point to default service network, instead of searching for service network with the same name. Can be used for small setups and conformance tests.</p>"},{"location":"guides/environment/#webhook_enabled","title":"<code>WEBHOOK_ENABLED</code>","text":"<p>Type: string</p> <p>Default: \"\"</p> <p>When set as \"true\", the controller will start the webhook listener responsible for pod readiness gate injection  (see <code>pod-readiness-gates.md</code>). This is disabled by default for <code>deploy.yaml</code> because the controller will not start  successfully without the TLS certificate for the webhook in place. While this can be fixed by running  <code>scripts/gen-webhook-cert.sh</code>, it requires manual action. The webhook is enabled by default for the Helm install as the Helm install will also generate the necessary certificate.</p>"},{"location":"guides/getstarted/","title":"Getting Started with AWS Gateway API Controller","text":"<p>This guide helps you get started using the controller.</p> <p>Following this guide, you will:</p> <ul> <li>Set up service-to-service communications with VPC Lattice on a single cluster.</li> <li>Create another service on a second cluster in a different VPC, and route traffic to that service across the two clusters and VPCs.</li> </ul> <p>Using these examples as a foundation, see the Concepts section for ways to further configure service-to-service communications.</p>"},{"location":"guides/getstarted/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding to the next sections, you need to:</p> <ul> <li>Create a cluster <code>gw-api-controller-demo</code> with the controller following the AWS Gateway API Controller installation guide on Amazon EKS.</li> <li> <p>Clone the AWS Gateway API Controller repository.</p> <p><pre><code>git clone https://github.com/aws/aws-application-networking-k8s.git\ncd aws-application-networking-k8s\n</code></pre> - Set the AWS Region of your cluster. <pre><code>export AWS_REGION=&lt;cluster_region&gt;\n</code></pre></p> </li> </ul>"},{"location":"guides/getstarted/#single-cluster","title":"Single cluster","text":"<p>This example creates a single cluster in a single VPC, then configures two HTTPRoutes (<code>rates</code> and <code>inventory</code>) and three kubetnetes services (<code>parking</code>, <code>review</code>, and <code>inventory-1</code>). The following figure illustrates this setup:</p> <p></p> <p>Setup in-cluster service-to-service communications</p> <ol> <li> <p>AWS Gateway API Controller needs a VPC Lattice service network to operate.</p> HelmAWS CLI <p>If you installed the controller with <code>helm</code>, you can update chart configurations by specifying the <code>defaultServiceNetwork</code> variable:</p> <pre><code>aws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws\nhelm upgrade gateway-api-controller \\\noci://public.ecr.aws/aws-application-networking-k8s/aws-gateway-controller-chart \\\n--version=v1.0.5 \\\n--reuse-values \\\n--namespace aws-application-networking-system \\\n--set=defaultServiceNetwork=my-hotel \n</code></pre> <p>You can use AWS CLI to manually create a VPC Lattice service network association to the previously created <code>my-hotel</code> service network:</p> <pre><code>aws vpc-lattice create-service-network --name my-hotel\nSERVICE_NETWORK_ID=$(aws vpc-lattice list-service-networks --query \"items[?name==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\nCLUSTER_VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME | jq -r .cluster.resourcesVpcConfig.vpcId)\naws vpc-lattice create-service-network-vpc-association --service-network-identifier $SERVICE_NETWORK_ID --vpc-identifier $CLUSTER_VPC_ID\n</code></pre> <p>Ensure the service network created above is ready to accept traffic from the new VPC, by checking if the VPC association status is <code>ACTIVE</code>:</p> <p><pre><code>aws vpc-lattice list-service-network-vpc-associations --vpc-id $CLUSTER_VPC_ID\n</code></pre> <pre><code>{\n    \"items\": [\n        {\n            ...\n            \"status\": \"ACTIVE\",\n            ...\n        }\n    ]\n}\n</code></pre></p> </li> <li> <p>Create the Kubernetes Gateway <code>my-hotel</code>:</p> <pre><code>kubectl apply -f files/examples/my-hotel-gateway.yaml\n</code></pre> <p>Verify that <code>my-hotel</code> Gateway is created with <code>PROGRAMMED</code> status equals to <code>True</code>:</p> <p><pre><code>kubectl get gateway\n</code></pre> <pre><code>NAME       CLASS                ADDRESS   PROGRAMMED   AGE\nmy-hotel   amazon-vpc-lattice               True      7d12h\n</code></pre></p> </li> <li> <p>Create the Kubernetes HTTPRoute <code>rates</code> that can has path matches routing to the <code>parking</code> service and <code>review</code> service:    <pre><code>kubectl apply -f files/examples/parking.yaml\nkubectl apply -f files/examples/review.yaml\nkubectl apply -f files/examples/rate-route-path.yaml\n</code></pre></p> </li> <li>Create another Kubernetes HTTPRoute <code>inventory</code>:    <pre><code>kubectl apply -f files/examples/inventory-ver1.yaml\nkubectl apply -f files/examples/inventory-route.yaml\n</code></pre></li> <li> <p>Find out HTTPRoute's DNS name from HTTPRoute status:</p> <p><pre><code>kubectl get httproute\n</code></pre> <pre><code>NAME        HOSTNAMES   AGE\ninventory               51s\nrates                   6m11s\n</code></pre></p> </li> <li> <p>Check VPC Lattice generated DNS address for HTTPRoute <code>inventory</code> and <code>rates</code> (this could take up to one minute to populate):</p> <p><pre><code>kubectl get httproute inventory -o yaml \n</code></pre> <pre><code>    apiVersion: gateway.networking.k8s.io/v1beta1\n    kind: HTTPRoute\n    metadata:\n        annotations:\n        application-networking.k8s.aws/lattice-assigned-domain-name: inventory-default-xxxxxx.xxxxx.vpc-lattice-svcs.us-west-2.on.aws\n    ...\n</code></pre></p> <p><pre><code>kubectl get httproute rates -o yaml\n</code></pre> <pre><code>    apiVersion: gateway.networking.k8s.io/v1beta1\n    kind: HTTPRoute\n    metadata:\n        annotations:\n        application-networking.k8s.aws/lattice-assigned-domain-name: rates-default-xxxxxx.xxxxxxxxx.vpc-lattice-svcs.us-west-2.on.aws\n    ...\n</code></pre></p> </li> <li> <p>If the previous step returns the expected response, store VPC Lattice assigned DNS names to variables.</p> <pre><code>ratesFQDN=$(kubectl get httproute rates -o json | jq -r '.metadata.annotations.\"application-networking.k8s.aws/lattice-assigned-domain-name\"')\ninventoryFQDN=$(kubectl get httproute inventory -o json | jq -r '.metadata.annotations.\"application-networking.k8s.aws/lattice-assigned-domain-name\"')\n</code></pre> <p>Confirm that the URLs are stored correctly:</p> <p><pre><code>echo \"$ratesFQDN \\n$inventoryFQDN\"\n</code></pre> <pre><code>rates-default-xxxxxx.xxxxxxxxx.vpc-lattice-svcs.us-west-2.on.aws \ninventory-default-xxxxxx.xxxxx.vpc-lattice-svcs.us-west-2.on.aws\n</code></pre></p> </li> </ol> <p>Verify service-to-service communications</p> <ol> <li> <p>Check connectivity from the <code>inventory-ver1</code> service to <code>parking</code> and <code>review</code> services:</p> <pre><code>kubectl exec deploy/inventory-ver1 -- curl -s $ratesFQDN/parking $ratesFQDN/review\n</code></pre> <pre><code>Requsting to Pod(parking-xxxxx): parking handler pod\nRequsting to Pod(review-xxxxxx): review handler pod\n</code></pre> </li> <li> <p>Check connectivity from the <code>parking</code> service to the <code>inventory-ver1</code> service:    <pre><code>kubectl exec deploy/parking -- curl -s $inventoryFQDN\n</code></pre> <pre><code>Requsting to Pod(inventory-xxx): Inventory-ver1 handler pod\n</code></pre>    Now you could confirm the service-to-service communications within one cluster is working as expected.</p> </li> </ol>"},{"location":"guides/getstarted/#multi-cluster","title":"Multi-cluster","text":"<p>This section builds on the previous one. We will be migrating the Kubernetes <code>inventory</code> service from a the EKS cluster we previously created to new cluster in a different VPC, located in the same AWS Account.</p> <p></p> <p>Set up <code>inventory-ver2</code> service and serviceExport in the second cluster</p> <p>Warning</p> <p>VPC Lattice is a regional service, so you will need to create this second cluster in the same AWS Region as <code>gw-api-controller-demo</code>. Keep this in mind when setting <code>AWS_REGION</code> variable in the following steps. <pre><code>export AWS_REGION=&lt;clusters_region&gt;\n</code></pre></p> <ol> <li> <p>Create a second Kubernetes cluster <code>gw-api-controller-demo-2</code> with the Controller installed (using the same instructions to create and install the controller on Amazon EKS used to create the first). </p> </li> <li> <p>For sake of simplicity, lets set some alias for our clusters in the Kubernetes config file.</p> <pre><code>aws eks update-kubeconfig --name gw-api-controller-demo --region $AWS_REGION --alias gw-api-controller-demo\naws eks update-kubeconfig --name gw-api-controller-demo-2 --region $AWS_REGION --alias gw-api-controller-demo-2\nkubectl config get-contexts\n</code></pre> </li> <li> <p>Ensure you're using the second cluster's <code>kubectl</code> context.     <pre><code>kubectl config current-context\n</code></pre>    If your context is set to the first cluster, switch it to use the second cluster one:     <pre><code>kubectl config use-context gw-api-controller-demo-2\n</code></pre></p> </li> <li> <p>Create the service network association.</p> HelmAWS CLI <p>If you installed the controller with <code>helm</code>, you can update chart configurations by specifying the <code>defaultServiceNetwork</code> variable:</p> <pre><code>aws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws\nhelm upgrade gateway-api-controller \\\noci://public.ecr.aws/aws-application-networking-k8s/aws-gateway-controller-chart \\\n--version=v1.0.5 \\\n--reuse-values \\\n--namespace aws-application-networking-system \\\n--set=defaultServiceNetwork=my-hotel \n</code></pre> <p>You can use AWS CLI to manually create a VPC Lattice service network association to the previously created <code>my-hotel</code> service network:</p> <pre><code>SERVICE_NETWORK_ID=$(aws vpc-lattice list-service-networks --query \"items[?name==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\nCLUSTER_VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME | jq -r .cluster.resourcesVpcConfig.vpcId)\naws vpc-lattice create-service-network-vpc-association --service-network-identifier $SERVICE_NETWORK_ID --vpc-identifier $CLUSTER_VPC_ID\n</code></pre> <p>Ensure the service network created above is ready to accept traffic from the new VPC, by checking if the VPC association status is <code>ACTIVE</code>:</p> <p><pre><code>aws vpc-lattice list-service-network-vpc-associations --vpc-id $CLUSTER_VPC_ID\n</code></pre> <pre><code>{\n    \"items\": [\n        {\n            ...\n            \"status\": \"ACTIVE\",\n            ...\n        }\n    ]\n}\n</code></pre></p> </li> <li> <p>Create the Kubernetes Gateway <code>my-hotel</code>:</p> <pre><code>kubectl apply -f files/examples/my-hotel-gateway.yaml\n</code></pre> <p>Verify that <code>my-hotel</code> Gateway is created with <code>PROGRAMMED</code> status equals to <code>True</code>:</p> <p><pre><code>kubectl get gateway\n</code></pre> <pre><code>NAME       CLASS                ADDRESS   PROGRAMMED   AGE\nmy-hotel   amazon-vpc-lattice               True      7d12h\n</code></pre></p> </li> <li> <p>Create a Kubernetes inventory-ver2 service in the second cluster:     <pre><code>kubectl apply -f files/examples/inventory-ver2.yaml\n</code></pre></p> </li> <li>Export this Kubernetes inventory-ver2 from the second cluster, so that it can be referenced by HTTPRoute in the first cluster:     <pre><code>kubectl apply -f files/examples/inventory-ver2-export.yaml\n</code></pre></li> </ol> <p>Switch back to the first cluster</p> <ol> <li>Switch context back to the first cluster     <pre><code>kubectl config use-context gw-api-controller-demo\n</code></pre></li> <li>Create Kubernetes service import <code>inventory-ver2</code> in the first cluster:     <pre><code>kubectl apply -f files/examples/inventory-ver2-import.yaml\n</code></pre></li> <li>Update the HTTPRoute <code>inventory</code> rules to route 10% traffic to the first cluster and 90% traffic to the second cluster:     <pre><code>kubectl apply -f files/examples/inventory-route-bluegreen.yaml\n</code></pre></li> <li> <p>Check the service-to-service connectivity from <code>parking</code>(in the first cluster) to <code>inventory-ver1</code>(in in the first cluster) and <code>inventory-ver2</code>(in in the second cluster):     <pre><code>inventoryFQDN=$(kubectl get httproute inventory -o json | jq -r '.metadata.annotations.\"application-networking.k8s.aws/lattice-assigned-domain-name\"')\nkubectl exec deploy/parking -- sh -c 'for ((i=1; i&lt;=30; i++)); do curl -s \"$0\"; done' \"$inventoryFQDN\"\n</code></pre></p> <pre><code>Requesting to Pod(inventory-ver2-6dc74b45d8-rlnlt): Inventory-ver2 handler pod &lt;----&gt; in 2nd cluster\nRequesting to Pod(inventory-ver2-6dc74b45d8-rlnlt): Inventory-ver2 handler pod\nRequesting to Pod(inventory-ver2-6dc74b45d8-rlnlt): Inventory-ver2 handler pod\nRequesting to Pod(inventory-ver2-6dc74b45d8-rlnlt): Inventory-ver2 handler pod\nRequesting to Pod(inventory-ver2-6dc74b45d8-95rsr): Inventory-ver1 handler pod &lt;----&gt; in 1st cluster\nRequesting to Pod(inventory-ver2-6dc74b45d8-rlnlt): Inventory-ver2 handler pod\nRequesting to Pod(inventory-ver2-6dc74b45d8-95rsr): Inventory-ver2 handler pod\nRequesting to Pod(inventory-ver2-6dc74b45d8-95rsr): Inventory-ver2 handler pod\nRequesting to Pod(inventory-ver1-74fc59977-wg8br): Inventory-ver1 handler pod....\n</code></pre> <p>You can see that the traffic is distributed between <code>inventory-ver1</code> and <code>inventory-ver2</code> as expected.</p> </li> </ol>"},{"location":"guides/getstarted/#cleanup","title":"Cleanup","text":"<p>To avoid additional charges, remove the demo infrastructure from your AWS account.</p> <p>Multi-cluster</p> <p>Delete resources in the Multi-cluster walkthrough.</p> <p>Warning</p> <p>Remember that you need to have the AWS Region set. <pre><code>export AWS_REGION=&lt;cluster_region&gt;\n</code></pre></p> <ol> <li> <p>Cleanup VPC Lattice service and service import in <code>gw-api-controller-demo</code> cluster: <pre><code>kubectl config use-context gw-api-controller-demo\nkubectl delete -f files/examples/inventory-route-bluegreen.yaml\nkubectl delete -f files/examples/inventory-ver2-import.yaml\n</code></pre></p> </li> <li> <p>Delete service export and applications in <code>gw-api-controller-demo-2</code> cluster: <pre><code>kubectl config use-context gw-api-controller-demo-2\nkubectl delete -f files/examples/inventory-ver2-export.yaml\nkubectl delete -f files/examples/inventory-ver2.yaml\n</code></pre></p> </li> <li> <p>Delete the service network association (this could take up to one minute): <pre><code>CLUSTER_NAME=gw-api-controller-demo-2\nCLUSTER_VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME | jq -r .cluster.resourcesVpcConfig.vpcId)\nSERVICE_NETWORK_ASSOCIATION_IDENTIFIER=$(aws vpc-lattice list-service-network-vpc-associations --vpc-id $CLUSTER_VPC_ID --query \"items[?serviceNetworkName==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\naws vpc-lattice delete-service-network-vpc-association  --service-network-vpc-association-identifier $SERVICE_NETWORK_ASSOCIATION_IDENTIFIER\n</code></pre></p> </li> </ol> <p>Single cluster</p> <p>Delete resources in the Single cluster walkthrough.</p> <p>Warning</p> <p>Remember that you need to have the AWS Region set. <pre><code>export AWS_REGION=&lt;cluster_region&gt;\n</code></pre></p> <ol> <li> <p>Delete VPC Lattice services and applications in <code>gw-api-controller-demo</code> cluster: <pre><code>kubectl config use-context gw-api-controller-demo\nkubectl delete -f files/examples/inventory-route.yaml\nkubectl delete -f files/examples/inventory-ver1.yaml\nkubectl delete -f files/examples/rate-route-path.yaml\nkubectl delete -f files/examples/parking.yaml\nkubectl delete -f files/examples/review.yaml\nkubectl delete -f files/examples/my-hotel-gateway.yaml\n</code></pre></p> </li> <li> <p>Delete the service network association (this could take up to one minute): <pre><code>CLUSTER_NAME=gw-api-controller-demo\nCLUSTER_VPC_ID=$(aws eks describe-cluster --name $CLUSTER_NAME | jq -r .cluster.resourcesVpcConfig.vpcId)\nSERVICE_NETWORK_ASSOCIATION_IDENTIFIER=$(aws vpc-lattice list-service-network-vpc-associations --vpc-id $CLUSTER_VPC_ID --query \"items[?serviceNetworkName==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\naws vpc-lattice delete-service-network-vpc-association  --service-network-vpc-association-identifier $SERVICE_NETWORK_ASSOCIATION_IDENTIFIER\n</code></pre></p> </li> </ol> <p>Cleanup VPC Lattice Resources</p> <ol> <li> <p>Cleanup controllers in <code>gw-api-controller-demo</code> and <code>gw-api-controller-demo-2</code> clusters:</p> HelmKubectl <pre><code>kubectl config use-context gw-api-controller-demo\nCLUSTER_NAME=gw-api-controller-demo\naws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws\nhelm uninstall gateway-api-controller --namespace aws-application-networking-system \nkubectl config use-context gw-api-controller-demo-2\nCLUSTER_NAME=gw-api-controller-demo-2\naws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws\nhelm uninstall gateway-api-controller --namespace aws-application-networking-system \n</code></pre> <pre><code>kubectl config use-context gw-api-controller-demo\nkubectl delete -f https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/deploy-v1.0.4.yaml\nkubectl config use-context gw-api-controller-demo-2\nkubectl delete -f https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/deploy-v1.0.4.yaml\n</code></pre> </li> <li> <p>Delete the service network:</p> <ol> <li>Ensure the service network associations have been deleted (do not move forward if the deletion is still <code>IN PROGRESS</code>): <pre><code>SN_IDENTIFIER=$(aws vpc-lattice list-service-networks --query \"items[?name==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\naws vpc-lattice list-service-network-vpc-associations --service-network-identifier $SN_IDENTIFIER\n</code></pre></li> <li>Delete <code>my-hotel</code> service network: <pre><code>aws vpc-lattice delete-service-network --service-network-identifier $SN_IDENTIFIER\n</code></pre></li> <li>Ensure the service network <code>my-hotel</code> is deleted: <pre><code>aws vpc-lattice list-service-networks\n</code></pre></li> </ol> </li> </ol> <p>Cleanup the clusters</p> <p>Finally, remember to delete the clusters you created for this walkthrough:</p> <ol> <li> <p>Delete <code>gw-api-controller-demo</code> cluster: <pre><code>eksctl delete cluster --name=gw-api-controller-demo\nk config delete-context gw-api-controller-demo\n</code></pre></p> </li> <li> <p>Delete <code>gw-api-controller-demo-2</code> cluster: <pre><code>eksctl delete cluster --name=gw-api-controller-demo-2\nk config delete-context gw-api-controller-demo-2\n</code></pre></p> </li> </ol>"},{"location":"guides/grpc/","title":"GRPCRoute Support","text":""},{"location":"guides/grpc/#what-is-grpcroute","title":"What is <code>GRPCRoute</code>?","text":"<p>The <code>GRPCRoute</code> is a custom resource defined in the Gateway API that specifies how gRPC traffic should be routed. It allows you to set up routing rules based on various match criteria, such as service names and methods. With <code>GRPCRoute</code>, you can ensure that your gRPC traffic is directed to the appropriate backend services in a Kubernetes environment.</p> <p>For a detailed reference on <code>GRPCRoute</code> from the Gateway API, please check the official Gateway API documentation.</p>"},{"location":"guides/grpc/#setting-up-a-helloworld-grpc-server","title":"Setting up a HelloWorld gRPC Server","text":"<p>In this section, we'll walk you through deploying a simple \"HelloWorld\" gRPC server and setting up the required routing rules using the Gateway API.</p> <p>Deploying the Necessary Resources</p> <ol> <li> <p>Apply the Gateway Configuration: This YAML file contains the definition for a gateway with an HTTPS listener.    <pre><code>kubectl apply -f files/examples/my-hotel-gateway-multi-listeners.yaml\n</code></pre></p> </li> <li> <p>Deploy the gRPC Server: Deploy the example gRPC server which will respond to the SayHello gRPC request.    <pre><code>kubectl apply -f files/examples/greeter-grpc-server.yaml\n</code></pre></p> </li> <li> <p>Set Up the gRPC Route:This YAML file contains the <code>GRPCRoute</code> resource which directs the gRPC traffic to our example server.    <pre><code>kubectl apply -f files/examples/greeter-grpc-route.yaml\n</code></pre></p> </li> <li> <p>Verify the Deployment:Check to make sure that our gRPC server pod is running and get its name.    <pre><code>kubectl get pods -A\n</code></pre></p> </li> </ol> <p>Testing the gRPC Server</p> <ol> <li> <p>Access the gRPC Server Pod: Copy the name of the pod running the <code>greeter-grpc-server</code> and use it to access the pod's shell.    <pre><code>kubectl exec -it &lt;name-of-grpc-server-pod&gt; -- bash\n</code></pre></p> </li> <li> <p>Prepare the Test Client: Inside the pod shell, create a test client by pasting the provided Go code.    <pre><code>cat &lt;&lt; EOF &gt; test.go\npackage main\n\nimport (\n   \"crypto/tls\"\n   \"log\"\n   \"os\"\n\n   \"golang.org/x/net/context\"\n   \"google.golang.org/grpc\"\n   \"google.golang.org/grpc/credentials\"\n   pb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n\nfunc main() {\n   if len(os.Args) &lt; 3 {\n   log.Fatalf(\"Usage: %s &lt;address&gt; &lt;port&gt;\", os.Args[0])\n   }\n\n   address := os.Args[1] + \":\" + os.Args[2]\n\n   // Create a connection with insecure TLS (no server verification).\n   creds := credentials.NewTLS(&amp;tls.Config{\n       InsecureSkipVerify: true,\n   })\n   conn, err := grpc.Dial(address, grpc.WithTransportCredentials(creds))\n   if err != nil {\n       log.Fatalf(\"did not connect: %v\", err)\n   }\n   defer conn.Close()\n   c := pb.NewGreeterClient(conn)\n\n   // Contact the server and print out its response.\n   name := \"world\"\n   if len(os.Args) &gt; 3 {\n       name = os.Args[3]\n   }\n   r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest{Name: name})\n   if err != nil {\n       log.Fatalf(\"could not greet: %v\", err)\n   }\n   log.Printf(\"Greeting: %s\", r.Message)\n}\nEOF\n</code></pre></p> </li> <li> <p>Run the Test Client: Execute the test client, making sure to replace <code>&lt;SERVICE DNS&gt;</code> with the VPC Lattice service DNS and <code>&lt;PORT&gt;</code>    with the port your Lattice listener uses (in this example, we use 443).    <pre><code>go run test.go &lt;SERVICE DNS&gt; &lt;PORT&gt;\n</code></pre></p> </li> </ol> <p>Expected Output</p> <p>If everything is set up correctly, you should see the following output:</p> <pre><code>Greeting: Hello world\n</code></pre> <p>This confirms that our gRPC request was successfully routed through VPC Lattice and processed by our <code>greeter-grpc-server</code>.</p>"},{"location":"guides/https/","title":"HTTPS","text":""},{"location":"guides/https/#configure-https-connections","title":"Configure HTTPs connections","text":"<p>The Getting Started guide uses <code>HTTP</code> communications by default. Using the examples here, you can change that to <code>HTTPs</code>. If you choose, you can further customize your <code>HTTPs</code> connections by adding custom domain names and certificates, as described below.</p> <p>NOTE: You can get the yaml files used on this page by cloning the AWS Gateway API Controller for VPC Lattice site. The files are in the <code>files/examples/</code> directory.</p>"},{"location":"guides/https/#securing-traffic-using-https","title":"Securing Traffic using HTTPs","text":"<p>By adding https to the amazon-vpc-lattice gateway, you can tell the listener to use HTTPs communications. The following modifications to the <code>files/examples/my-hotel-gateway.yaml</code> file add HTTPs communications:</p> my-hotel-gateway.yaml<pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: my-hotel\nspec:\n  gatewayClassName: amazon-vpc-lattice\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n  - name: https         # Specify https listener\n    protocol: HTTPS     # Specify HTTPS protocol\n    port: 443           # Specify communication on port 443\n...\n</code></pre> <p>Next, the following modifications to the <code>files/examples/rate-route-path.yaml</code> file tell the <code>rates</code> HTTPRoute to use HTTPs for communications:</p> rate-route-path.yaml<pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: rates\nspec:\n  parentRefs:\n  - name: my-hotel\n    sectionName: http \n  - name: my-hotel      # Specify the parertRefs name\n    sectionName: https  # Specify all traffic MUST use HTTPs\n  rules:\n...\n</code></pre> <p>In this case, the VPC Lattice service automatically generates a managed ACM certificate and uses it for encryting client to service traffic.</p>"},{"location":"guides/https/#bring-your-own-certificate-byoc","title":"Bring Your Own Certificate (BYOC)","text":"<p>If you want to use a custom domain name along with its own certificate, you can:</p> <ul> <li>Follow instructions on Requesting a public certificate and get an ACM certificate ARN.</li> <li>Add the ARN to the listener configuration as shown below.</li> </ul> <p>The following shows modifications to <code>files/examples/my-hotel-gateway.yaml</code> to add a custom certificate:</p> <p>my-hotel-gateway.yaml<pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: my-hotel\n  annotations:\n    application-networking.k8s.aws/lattice-vpc-association: \"true\"\nspec:\n  gatewayClassName: amazon-vpc-lattice\n  listeners:\n  - name: http\n    protocol: HTTP\n    port: 80\n  - name: https\n    protocol: HTTPS      # This is required\n    port: 443\n    tls:\n      mode: Terminate    # This is required\n      certificateRefs:   # This is required per API spec, but currently not used by the controller\n      - name: unused\n      options:           # Instead, we specify ACM certificate ARN under this section\n        application-networking.k8s.aws/certificate-arn: arn:aws:acm:us-west-2:&lt;account&gt;:certificate/&lt;certificate-id&gt;\n</code></pre> Note that only <code>Terminate</code> mode is supported (Passthrough is not supported).</p> <p>Next, associate the HTTPRoute to the listener configuration you just configured:</p> rate-route-path.yaml<pre><code>apiVersion: gateway.networking.k8s.io/v1beta1\nkind: HTTPRoute\nmetadata:\n  name: rates\nspec:\n  hostnames:\n    - review.my-test.com               # MUST match the DNS in the certificate\n  parentRefs:\n  - name: my-hotel\n    sectionName: http \n  - name: my-hotel                     # Use the listener defined above as parentRef\n    sectionName: https\n...\n</code></pre>"},{"location":"guides/https/#enabling-tls-connection-on-the-backend","title":"Enabling TLS connection on the backend","text":"<p>Currently, TLS Passthrough mode is not supported in the controller, but it allows TLS re-encryption to support backends that only allow TLS connections. To handle this use case, you need to configure your service to receive HTTPs traffic instead:</p> target-group.yaml<pre><code>apiVersion: application-networking.k8s.aws/v1alpha1\nkind: TargetGroupPolicy\nmetadata:\n    name: test-policy\nspec:\n    targetRef:\n        group: \"\"\n        kind: Service\n        name: my-parking-service # Put service name here\n    protocol: HTTPS\n    protocolVersion: HTTP1\n</code></pre> <p>This will create VPC Lattice TargetGroup with HTTPs protocol option, which can receive TLS traffic. Note that certificate validation is not supported.</p> <p>For more details, please refer to TargetGroupPolicy API reference.</p>"},{"location":"guides/pod-readiness-gates/","title":"Pod readiness gate","text":"<p>AWS Gateway API controller supports \u00bbPod readiness gates\u00ab to indicate that pod is registered to the VPC Lattice and healthy to receive traffic. The controller automatically injects the necessary readiness gate configuration to the pod spec via mutating webhook during pod creation.</p> <p>For readiness gate configuration to be injected to the pod spec, you need to apply the label <code>application-networking.k8s.aws/pod-readiness-gate-inject: enabled</code> to the pod namespace. </p> <p>The pod readiness gate is needed under certain circumstances to achieve full zero downtime rolling deployments. Consider the following example:</p> <ul> <li>Low number of replicas in a deployment</li> <li>Start a rolling update of the deployment</li> <li>Rollout of new pods takes less time than it takes the AWS Gateway API controller to register the new pods and for their health state turn \u00bbHealthy\u00ab in the target group</li> <li>At some point during this rolling update, the target group might only have registered targets that are in \u00bbInitial\u00ab or \u00bbDraining\u00ab state; this results in service outage</li> </ul> <p>In order to avoid this situation, the AWS Gateway API controller can set the readiness condition on the pods that constitute your ingress or service backend. The condition status on a pod will be set to <code>True</code> only when the corresponding target in the VPC Lattice target group shows a health state of \u00bbHealthy\u00ab. This prevents the rolling update of a deployment from terminating old pods until the newly created pods are \u00bbHealthy\u00ab in the VPC Lattice target group and ready to take traffic.</p>"},{"location":"guides/pod-readiness-gates/#setup","title":"Setup","text":"<p>Pod readiness gates rely on \u00bbadmission webhooks\u00ab, where the Kubernetes API server makes calls to the AWS Gateway API controller as part of pod creation. This call is made using TLS, so the controller must present a TLS certificate. This certificate is stored as a standard Kubernetes secret. If you are using Helm, the certificate will automatically be configured as part of the Helm install.</p> <p>If you are manually deploying the controller using the <code>deploy.yaml</code> file, you will need to either patch the <code>deploy.yaml</code> file (see <code>scripts/patch-deploy-yaml.sh</code>) or generate the secret following installation (see <code>scripts/gen-webhook-secret.sh</code>) and manually enable the webhook via the <code>WEBHOOK_ENABLED</code> environment variable.</p> <p>Note that, without the secret in place, the controller cannot start successfully, and you will see an error message like the following: <pre><code>{\"level\":\"error\",\"ts\":\"...\",\"logger\":\"setup\",\"caller\":\"workspace/main.go:240\",\"msg\":\"tls: failed to find any PEM data in certificate inputproblem running manager\"}\n</code></pre> For this reason, the webhook is <code>DISABLED</code> by default in the controller for the non-Helm install. You can enable the webhook by setting the <code>WEBHOOK_ENABLED</code> environment variable to \"true\" in the <code>deploy.yaml</code> file. <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: gateway-api-controller\n  namespace: aws-application-networking-system\n  labels:\n    control-plane: gateway-api-controller\nspec:\n  ...\n  template:\n    metadata:\n      annotations:\n        kubectl.kubernetes.io/default-container: manager\n      labels:\n        control-plane: gateway-api-controller\n    spec:\n      securityContext:\n        runAsNonRoot: true\n      containers:\n      - command:\n        ...\n        name: manager\n        ...\n        env:\n          - name: WEBHOOK_ENABLED\n            value: \"true\"   # &lt;-- value of \"true\" enables the webhook in the controller\n</code></pre> If you run <code>scripts/patch-deploy-yaml.sh</code> prior to installing <code>deploy.yaml</code>, the script will create the necessary TLS certificates and configuration and will enable the webhook in the controller. Note that, even with the webhook enabled, the webhook will only run for namespaces labeled with <code>application-networking.k8s.aws/pod-readiness-gate-inject: enabled</code>.  </p>"},{"location":"guides/pod-readiness-gates/#enabling-the-readiness-gate","title":"Enabling the readiness gate","text":"<p>After a Helm install or manually configuring and enabling the webhook, you are ready to begin using pod readiness gates. Apply a label to each namespace you would like to use this feature. You can create and label a namespace as follows -</p> <pre><code>$ kubectl create namespace example-ns\nnamespace/example-ns created\n\n$ kubectl label namespace example-ns application-networking.k8s.aws/pod-readiness-gate-inject=enabled\nnamespace/example-ns labeled\n\n$ kubectl describe namespace example-ns\nName:         example-ns\nLabels:       application-networking.k8s.aws/pod-readiness-gate-inject=enabled\n              kubernetes.io/metadata.name=example-ns\nAnnotations:  &lt;none&gt;\nStatus:       Active\n</code></pre> <p>Once labelled, the controller will add the pod readiness gates to all subsequently created pods in the namespace.</p> <p>The readiness gates have the condition type <code>application-networking.k8s.aws/pod-readiness-gate</code> and the controller injects the config to the pod spec only during pod creation.</p>"},{"location":"guides/pod-readiness-gates/#object-selector","title":"Object Selector","text":"<p>The default webhook configuration matches all pods in the namespaces containing the label <code>application-networking.k8s.aws/pod-readiness-gate-inject=enabled</code>. You can modify the webhook configuration further to select specific pods from the labeled namespace by specifying the <code>objectSelector</code>. For example, in order to select ONLY pods with <code>application-networking.k8s.aws/pod-readiness-gate-inject: enabled</code> label instead of all pods in the labeled namespace, you can add the following <code>objectSelector</code> to the webhook: <pre><code>  objectSelector:\n    matchLabels:\n      application-networking.k8s.aws/pod-readiness-gate-inject: enabled\n</code></pre> To edit, <pre><code>$ kubectl edit mutatingwebhookconfigurations aws-appnet-gwc-mutating-webhook\n  ...\n  name: mpod.gwc.k8s.aws\n  namespaceSelector:\n    matchExpressions:\n    - key: application-networking.k8s.aws/pod-readiness-gate-inject\n      operator: In\n      values:\n      - enabled\n  objectSelector:\n    matchLabels:\n      application-networking.k8s.aws/pod-readiness-gate-inject: enabled\n  ...\n</code></pre> When you specify multiple selectors, pods matching all the conditions will get mutated.</p>"},{"location":"guides/pod-readiness-gates/#checking-the-pod-condition-status","title":"Checking the pod condition status","text":"<p>The status of the readiness gates can be verified with <code>kubectl get pod -o wide</code>: <pre><code>NAME                          READY   STATUS    RESTARTS   AGE   IP         NODE                       READINESS GATES\nnginx-test-5744b9ff84-7ftl9   1/1     Running   0          81s   10.1.2.3   ip-10-1-2-3.ec2.internal   0/1\n</code></pre></p> <p>When the target is registered and healthy in the VPC Lattice target group, the output will look like: <pre><code>NAME                          READY   STATUS    RESTARTS   AGE   IP         NODE                       READINESS GATES\nnginx-test-5744b9ff84-7ftl9   1/1     Running   0          81s   10.1.2.3   ip-10-1-2-3.ec2.internal   1/1\n</code></pre></p> <p>If a readiness gate doesn't get ready, you can check the reason via:</p> <pre><code>$ kubectl get pod nginx-test-545d8f4d89-l7rcl -o yaml | grep -B7 'type: application-networking.k8s.aws/pod-readiness-gate'\nstatus:\n  conditions:\n  - lastProbeTime: null\n    lastTransitionTime: null\n    reason: HEALTHY\n    status: \"True\"\n    type: application-networking.k8s.aws/pod-readiness-gate\n</code></pre>"},{"location":"guides/ram-sharing/","title":"Share Kubernetes Gateway (VPC Lattice Service Network) between different AWS accounts","text":"<p>AWS Resource Access Manager (AWS RAM) helps you share your resources across AWS Accounts, within your AWS Organization or Organizational Units (OUs).  RAM supports 2 types of VPC Lattice resource sharing: VPC Lattice services and service networks.</p> <p>Let's build an example where Account A (sharer account)  shares its service network with Account B (sharee account), and Account B can access all Kubernetes <code>services</code> (VPC Lattice Target Groups) and Kubernetes <code>HTTPRoutes</code>(VPC Lattice services) within this sharer account's service network.</p> <p>Create a VPC Lattice Resources</p> <p>In Account A, set up a cluster with the Controller and an example application installed. You can follow the Getting Started guide  up to the \"Single Cluster\" section.</p> <p>Share the VPC Lattice Service Network</p> <p>Now that we have a VPC Lattice service network and service in Account A , share this service network to Account B.</p> <ol> <li> <p>Retrieve the <code>my-hotel</code> service network Identifier:     <pre><code>aws vpc-lattice list-service-networks --query \"items[?name==\"\\'my-hotel\\'\"].id\" | jq -r '.[]'\n</code></pre></p> </li> <li> <p>Share the <code>my-hotel</code> service network, using the identifier retrieved in the previous step.</p> <ol> <li>Open the AWS RAM console in Account A and create a resource share.  </li> <li>Select <code>VPC Lattice service network</code> resource sharing type.  </li> <li>Select the <code>my-hotel</code> service network identifier retrieved in the previous step.  </li> <li>Associate AWS Managed Permissions.  </li> <li>Set Account B as principal.  </li> <li>Review and create the resource share.  </li> </ol> </li> <li> <p>Open the Account B's AWS RAM console and accept Account A's service network sharing invitation in the \"Shared with me\" section. </p> <p> </p> </li> <li> <p>Switch back to Account A, retrieve the service network ID.</p> <pre><code>SERVICE_NETWORK_ID=$(aws vpc-lattice list-service-networks --query \"items[?name==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\necho $SERVICE_NETWORK_ID\n</code></pre> </li> <li> <p>Switch to Account B and verify that <code>my-hotel</code> service network resource is available in Account B (referring to the <code>SERVICE_NETWORK_ID</code> retrived in the previous step).</p> </li> <li> <p>Now choose an Amazon VPC in Account B to attach to the <code>my-hotel</code> service network.</p> <pre><code>VPC_ID=&lt;your_vpc_id&gt;\naws vpc-lattice create-service-network-vpc-association --service-network-identifier $SERVICE_NETWORK_ID --vpc-identifier $VPC_ID\n</code></pre> <p>Warning</p> <p>VPC Lattice is a regional service, therefore the VPC must be in the same AWS Region of the service network you created in Account A. </p> </li> </ol> <p>Test cross-account connectivity</p> <p>You can verify that the <code>parking</code> and <code>review</code> microservices - in Account A - can be consumed from resources in  the assocuated VPC in Account B. </p> <ol> <li> <p>To simplify, let's create and connect to a Cloud9 environment in the VPC you previously attached to the <code>my-hotel</code> service network. </p> </li> <li> <p>In Account A, retrieve the VPC Lattice services urls.     <pre><code>ratesFQDN=$(aws vpc-lattice list-services --query \"items[?name==\"\\'rates-default\\'\"].dnsEntry\" | jq -r '.[].domainName')\ninventoryFQDN=$(aws vpc-lattice list-services --query \"items[?name==\"\\'inventory-default\\'\"].dnsEntry\" | jq -r '.[].domainName')\necho \"$ratesFQDN \\n$inventoryFQDN\"\n</code></pre>     ```</p> </li> <li> <p>In the Cloud9 instance in Account B, install <code>curl</code> in the instance and curl <code>parking</code> and <code>rates</code> microservices:</p> <pre><code>sudo apt-get install curl\ncurl $ratesFQDN/parking $ratesFQDN/review\n</code></pre> </li> </ol> <p>Cleanup</p> <p>To avoid additional charges, remove the demo infrastructure from your AWS Accounts.</p> <ol> <li> <p>Delete the service network Association you created in Account B. In Account A:     <pre><code>VPC_ID=&lt;accountB_vpc_id&gt;\nSERVICE_NETWORK_ASSOCIATION_IDENTIFIER=$(aws vpc-lattice list-service-network-vpc-associations --vpc-id $VPC_ID --query \"items[?serviceNetworkName==\"\\'my-hotel\\'\"].id\" | jq -r '.[]')\naws vpc-lattice delete-service-network-vpc-association  --service-network-vpc-association-identifier $SERVICE_NETWORK_ASSOCIATION_IDENTIFIER\n</code></pre></p> <p>Ensure the service network Association is deleted: <pre><code>aws vpc-lattice list-service-network-vpc-associations --vpc-id $VPC_ID\n</code></pre></p> </li> <li> <p>Delete the service network RAM share resource in AWS RAM Console.</p> </li> <li> <p>Follow the cleanup section of the getting Started guide to delete Cluster and service network Resources in Account A.</p> </li> <li> <p>Delete the Cloud9 Environment in Account B. </p> </li> </ol>"},{"location":"guides/tls-passthrough/","title":"TLS Passthrough Support","text":"<p>Kubernetes Gateway API lays out the general guidelines on how to configure TLS passthrough. Here are examples on how to use them against AWS Gateway Api controller and VPC Lattice.</p>"},{"location":"guides/tls-passthrough/#install-gateway-api-tlsroute-crd","title":"Install Gateway API TLSRoute CRD","text":"<p>The TLSRoute CRD is already included in the helm chart and deployment.yaml, if you are using these 2 methods to install the controller no extra steps needed. If you want to install the TLSRoute CRD manually by yourself: <pre><code># Install CRD\nkubectl apply -f config/crds/bases/gateway.networking.k8s.io_tlsroutes.yaml\n# Verfiy TLSRoute CRD \nkubectl get crd tlsroutes.gateway.networking.k8s.io \nNAME                                  CREATED AT\ntlsroutes.gateway.networking.k8s.io   2024-03-07T23:16:22Z\n</code></pre></p>"},{"location":"guides/tls-passthrough/#setup-tls-passthrough-connectivity-in-a-single-cluster","title":"Setup TLS Passthrough Connectivity in a single cluster","text":""},{"location":"guides/tls-passthrough/#1-configure-tls-passthrough-listener-on-gateway","title":"1. Configure TLS Passthrough Listener on Gateway","text":"<pre><code>kubectl apply -f files/examples/my-gateway-tls-passthrough.yaml\n</code></pre> <pre><code># tls listener config snips:\napiVersion: gateway.networking.k8s.io/v1beta1\nkind: Gateway\nmetadata:\n  name: my-hotel-tls-passthrough\nspec:\n  gatewayClassName: amazon-vpc-lattice\n  listeners:\n  ...\n  - name: tls\n    protocol: TLS \n    port: 443\n    tls:\n      mode: Passthrough \n  ...\n</code></pre>"},{"location":"guides/tls-passthrough/#2-configure-tlsroute","title":"2. Configure TLSRoute","text":"<pre><code># Suppose in the below example, we use the \"parking\" service as the client pod to test the TLS passthrough traffic.\nkubectl apply -f files/examples/parking.yaml\n\n# Configure nginx backend service (This nginx image includes a self-signed certificate)\nkubectl apply -f files/example/nginx-server-tls-passthrough.yaml\n\n# configure nginx tls route\nkubectl apply -f files/examples/tlsroute-nginx.yaml\n</code></pre>"},{"location":"guides/tls-passthrough/#3-verify-the-controller-has-reconciled-nginx-tls-route","title":"3. Verify the controller has reconciled nginx-tls route","text":"<p>Make sure the TLSRoute has the <code>application-networking.k8s.aws/lattice-assigned-domain-name</code> annotation and status <code>Accepted: True</code> <pre><code>kubectl get tlsroute nginx-tls -o yaml\napiVersion: gateway.networking.k8s.io/v1alpha2\nkind: TLSRoute\nmetadata:\n  annotations:\n    application-networking.k8s.aws/lattice-assigned-domain-name: nginx-tls-default-0af995120af2711bc.7d67968.vpc-lattice-svcs.us-west-2.on.aws\n    ...\n  name: nginx-tls\n  namespace: default\n ...\n\nstatus:\n  parents:\n  - conditions:\n    - lastTransitionTime: .....\n      message: \"\"\n      observedGeneration: 1\n      reason: Accepted\n      status: \"True\"\n      type: Accepted\n    - lastTransitionTime: .....\n      message: \"\"\n      observedGeneration: 1\n      reason: ResolvedRefs\n      status: \"True\"\n      type: ResolvedRefs\n    controllerName: application-networking.k8s.aws/gateway-api-controller\n</code></pre></p>"},{"location":"guides/tls-passthrough/#4-verify-tls-passthrough-traffic","title":"4. Verify TLS Passthrough Traffic","text":"<pre><code>kubectl get deployment nginx-tls \nNAME        READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-tls   2/2     2            2           1d\n\n# Use the specified TLSRoute hostname to send traffic to the beackend nginx service\nkubectl exec deployments/parking  -- curl -kv  https://nginx-test.my-test.com  --resolve nginx-test.my-test.com:443:169.254.171.0\n\n* Trying 169.254.171.0:443...\n* Connected to nginx-test.my-test.com (169.254.171.0) port 443 (#0)\n....\n* TLSv1.2 (OUT), TLS header, Certificate Status (22):\n* TLSv1.2 (OUT), TLS handshake, Client hello (1):\n* TLSv1.2 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS handshake, Finished (20):    \n* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (IN), TLS handshake, Finished (20):   &lt;---------- TLS Handshake from client pod to the backend `nginx-tls` pod successfully, no tls termination in the middle\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server accepted to use h2\n....\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n....\n</code></pre>"},{"location":"guides/tls-passthrough/#setup-tls-passthrough-connectivity-spanning-multiple-clusters","title":"Setup TLS Passthrough Connectivity spanning multiple clusters","text":""},{"location":"guides/tls-passthrough/#1-in-this-example-we-still-use-the-parking-kubernetes-service-as-the-client-pod-to-test-the-cross-cluster-tls-passthrough-traffic","title":"1. In this example we still use the \"parking\" Kubernetes service as the client pod to test the cross cluster TLS passthrough traffic.","text":"<pre><code>kubectl apply -f files/examples/parking.yaml\n</code></pre>"},{"location":"guides/tls-passthrough/#2-in-cluster-1-create-tls-rate1-kubernetes-service","title":"2. In cluster-1, create <code>tls-rate1</code> Kubernetes Service:","text":"<pre><code>kubectl apply -f files/examples/tls-rate1.yaml\n</code></pre>"},{"location":"guides/tls-passthrough/#3-configure-serviceexport-with-targetgrouppolicy-protocoltcp-in-cluster-2","title":"3. Configure ServiceExport with TargetGroupPolicy <code>protocol:TCP</code> in cluster-2","text":"<pre><code># Create tls-rate2 Kubernetes Service in cluster-2\nkubectl apply -f files/examples/tls-rate2.yaml\n# Create serviceexport in cluster-2\nkubectl apply -f files/examples/tls-rate2-export.yaml\n# Create targetgroup policy to configure TCP protocol for tls-rate2 in cluster-2\nkubectl apply -f files/examples/tls-rate2-targetgrouppolicy.yaml\n</code></pre> <pre><code># Snips of serviceexport config\napiVersion: application-networking.k8s.aws/v1alpha1\nkind: ServiceExport\nmetadata:\n  name: tls-rate-2\n  annotations:\n    application-networking.k8s.aws/federation: \"amazon-vpc-lattice\"\n# Snips of targetgroup policy config\napiVersion: application-networking.k8s.aws/v1alpha1\nkind: TargetGroupPolicy\nmetadata:\n    name: tls-rate2\nspec:\n    targetRef:\n        group: \"application-networking.k8s.aws\"\n        kind: ServiceExport\n        name: tls-rate2\n    protocol: TCP\n</code></pre>"},{"location":"guides/tls-passthrough/#4-configure-serviceimport-in-cluster1","title":"4.  Configure ServiceImport in cluster1","text":"<pre><code>kubectl apply -f files/examples/tls-rate2-import.yaml\n</code></pre>"},{"location":"guides/tls-passthrough/#5-configure-tlsroute-for-bluegreen-deployment","title":"5. Configure TLSRoute for blue/green deployment","text":"<pre><code>kubectl apply -f files/examples/rate-tlsroute-bluegreen.yaml\n\n# snips of TLSRoute span multiple Kubernetes Clusters\napiVersion: gateway.networking.k8s.io/v1alpha2\nkind: TLSRoute\nmetadata:\n  name: tls-rate\nspec:\n  hostnames:\n  - tls-rate.my-test.com\n  parentRefs:\n  - name: my-hotel-tls\n    sectionName: tls\n  rules:\n  - backendRefs:\n    - name: tls-rate1 &lt;---------- to Kubernetes Cluster-1\n      kind: Service\n      port: 443\n      weight: 10\n    - name: tls-rate2 &lt;---------- to Kubernetes Cluster-2\n      kind: ServiceImport\n      port: 443\n      weight: 90  \n</code></pre>"},{"location":"guides/tls-passthrough/#6-verify-cross-cluster-tls-passthrough-traffic","title":"6. Verify cross-cluster TLS passthrough traffic","text":"<p>Expected to receive the weighted traffic route to tls-rate1 service(10%) and tls-rate2 service(90%), if you curl the <code>tls-rate.my-test.com</code> from the client pod multiple times: <pre><code>kubectl exec deploy/parking -- sh -c 'for ((i=1; i&lt;=30; i++)); do curl -k https://tls-rate.my-test.com --resolve tls-rate.my-test.com:443:169.254.171.0 2&gt;/dev/null; done'\n\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod &lt;----&gt;  k8s service in cluster-2\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod\nRequsting to TLS Pod(tls-rate1-98cc7fd87a-642zw): tls-rate1 handler pod &lt;----&gt; k8s service in cluster-1\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod\nRequsting to TLS Pod(tls-rate2-7f8b9cc97b-fgqk6): tls-rate2 handler pod\nRequsting to TLS Pod(tls-rate1-98cc7fd87a-642zw): tls-rate1 handler pod\n</code></pre></p>"}]}